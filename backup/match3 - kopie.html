<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=600, initial-scale=1.0" />
  <title>Match-3 Game</title>
  <style>
    body { margin: 0; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; min-height: 100vh; background: #222; }
    #gameWrapper { margin-top: 32px; }
    canvas { background: #333; border-radius: 16px; box-shadow: 0 4px 32px #000a; display: block; }
    #resetBtn {
      margin-bottom: 18px;
      margin-top: 38px;
      font-family: 'Segoe UI', Arial, sans-serif;
      font-weight: bold;
      font-size: 22px;
      background: linear-gradient(90deg, #e74c3c 0%, #3498db 100%);
      color: #fff;
      padding: 10px 44px;
      border: none;
      border-radius: 999px;
      box-shadow: 0 2px 16px #0005;
      cursor: pointer;
      letter-spacing: 1.5px;
      transition: transform 0.07s;
      outline: none;
    }
    #resetBtn:active { transform: scale(0.97);}
  </style>
</head>
<body>
  <button id="resetBtn">Reset</button>
  <div id="gameWrapper">
    <canvas id="gameCanvas" width="600" height="700"></canvas>
  </div>
  <script>
    // --- Config ---
    const GRID_SIZE = 10;
    const TOPBAR_HEIGHT = 60;
    const CELL_SIZE = 60;
    const CANVAS_W = CELL_SIZE * GRID_SIZE;
    const CANVAS_H = TOPBAR_HEIGHT + CELL_SIZE * GRID_SIZE;
    const COLORS = ['#e74c3c', '#f39c12', '#f1c40f', '#2ecc71', '#3498db', '#9b59b6'];
    const FALL_SPEED = 8, MATCH_ANIM_SPEED = 0.08, SWAP_SPEED = 0.2;

    const canvas = document.getElementById('gameCanvas');
    const resetBtn = document.getElementById('resetBtn');
    canvas.width = CANVAS_W;
    canvas.height = CANVAS_H;
    const ctx = canvas.getContext('2d');
    let grid = [];
    let animating = false;
    let dragStart = null;
    let score = 0;
    let combo = 0;
    let swapState = null;
    let specialsToTrigger = [];
    let timer = 60, timerInterval = null, timeUp = false;

    // DEBUG MODE VARS
    let debugMode = false;
    let debugSelector = null;

    class Tile {
      constructor(color, x, y) {
        this.color = color;
        this.x = x;
        this.y = y;
        this.px = x * CELL_SIZE;
        this.py = y * CELL_SIZE + TOPBAR_HEIGHT;
        this.scale = 1;
        this.alpha = 1;
        this.rotation = 0;
        this.matching = false;
        this.toRemove = false;
        this.animProgress = 0;
        this.targetPy = this.py;
        this.special = null; // 'horizontal','vertical','bomb','color'
      }
      draw() {
        const size = CELL_SIZE * this.scale;
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.translate(this.px + CELL_SIZE / 2, this.py + CELL_SIZE / 2);
        ctx.rotate(this.rotation);
        ctx.fillStyle = this.color;
        ctx.fillRect(-size / 2, -size / 2, size, size);
        // Draw special marker
        if (this.special) {
          ctx.strokeStyle = '#fff'; ctx.lineWidth = 3;
          if (this.special === 'horizontal') {
            ctx.beginPath(); ctx.moveTo(-size/2,0); ctx.lineTo(size/2,0); ctx.stroke();
          } else if (this.special === 'vertical') {
            ctx.beginPath(); ctx.moveTo(0,-size/2); ctx.lineTo(0,size/2); ctx.stroke();
          } else if (this.special === 'bomb') {
            ctx.beginPath(); ctx.arc(0,0,size/4,0,2*Math.PI); ctx.stroke();
          } else if (this.special === 'color') {
            ctx.beginPath(); ctx.moveTo(-size/2,-size/2); ctx.lineTo(size/2,size/2);
            ctx.moveTo(size/2,-size/2); ctx.lineTo(-size/2,size/2); ctx.stroke();
          }
        }
        ctx.restore();
      }
      update() {
        if (!swapState && this.py < this.targetPy) {
          this.py = Math.min(this.py + FALL_SPEED, this.targetPy);
        }
        if (this.matching) {
          this.animProgress += MATCH_ANIM_SPEED;
          const t = Math.min(this.animProgress, 1);
          this.scale = 1 + Math.sin(t * Math.PI) * 0.8;
          this.rotation = t * 2 * Math.PI;
          this.alpha = 1 - t;
          if (this.animProgress >= 1) {
            this.matching = false;
            return 'remove';
          }
        }
        return null;
      }
    }

    // --- Init ---
    function startGame() {
      grid = [];
      score = 0; combo = 0; timeUp = false;
      timer = 60;
      specialsToTrigger = [];
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        if (animating) return;
        timer--;
        if (timer <= 0) { timer = 0; timeUp = true; clearInterval(timerInterval);}
        draw();
      }, 1000);
      for (let y = 0; y < GRID_SIZE; y++) {
        const row = [];
        for (let x = 0; x < GRID_SIZE; x++) row.push(new Tile(randomColor(), x, y));
        grid.push(row);
      }
      clearInitialMatches();
      draw();
      resetBtn.textContent = "Reset";
    }
    function randomColor() { return COLORS[Math.floor(Math.random() * COLORS.length)]; }
    function clearInitialMatches() {
      let gs = getGroups();
      while (gs.length) {
        gs.forEach(g => g.positions.forEach(p => grid[p.y][p.x].color = randomColor()));
        gs = getGroups();
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Top bar
      ctx.save();
      ctx.globalAlpha = 0.96;
      ctx.fillStyle = "#1a1a1a";
      ctx.fillRect(0,0,canvas.width,TOPBAR_HEIGHT);
      ctx.globalAlpha = 1;
      ctx.font = 'bold 26px Segoe UI, Arial, sans-serif';
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'left';
      ctx.fillText(`Score: ${score}`, 24, 40);
      ctx.textAlign = 'center';
      ctx.fillStyle = combo > 1 ? '#2ecc71' : '#fff';
      ctx.fillText(`Combo: x${combo>1?combo:1}`, CANVAS_W/2, 40);
      ctx.textAlign = 'right';
      ctx.fillStyle = timer <= 10 ? '#e74c3c' : '#fff';
      ctx.fillText(`Time: ${timer}`, CANVAS_W-24, 40);
      ctx.restore();

      grid.flat().forEach(t => t.draw());

      if (debugMode) {
        ctx.fillStyle = "#fff";
        ctx.font = "bold 22px Segoe UI, Arial";
        ctx.fillText("DEBUG MODE", CANVAS_W-165, 28);
        drawDebugSelector();
      }

      if (timeUp) {
        ctx.save();
        ctx.globalAlpha = 0.8;
        ctx.fillStyle = "#111";
        ctx.fillRect(0, TOPBAR_HEIGHT, canvas.width, canvas.height-TOPBAR_HEIGHT);
        ctx.globalAlpha = 1;
        ctx.fillStyle = "#fff";
        ctx.font = "bold 60px Segoe UI, Arial, sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Time's Up!", CANVAS_W/2, CANVAS_H/2-30);
        ctx.font = "bold 36px Segoe UI, Arial, sans-serif";
        ctx.fillText(`Final Score: ${score}`, CANVAS_W/2, CANVAS_H/2+30);
        ctx.font = "24px Segoe UI, Arial, sans-serif";
        ctx.fillText("Press Restart or [R]", CANVAS_W/2, CANVAS_H/2+80);
        ctx.restore();
        resetBtn.textContent = "Restart";
      }
    }

    // Debug selector UI
    function drawDebugSelector() {
      if (!debugSelector) return;
      ctx.save();
      ctx.globalAlpha = 0.97;
      ctx.fillStyle = "#181a2a";
      ctx.fillRect(0, 0, CANVAS_W, 32 + 32);
      // Color buttons
      COLORS.forEach((c,i) => {
        ctx.fillStyle = c;
        ctx.fillRect(8 + i*42, 4, 36, 24);
        ctx.strokeStyle = '#fff';
        ctx.strokeRect(8 + i*42, 4, 36, 24);
      });
      // Special buttons
      const specials = ['none','horizontal','vertical','bomb','color'];
      specials.forEach((s,i)=>{
        ctx.fillStyle = "#555";
        ctx.fillRect(8 + i*60, 36, 54, 24);
        ctx.strokeStyle = '#fff';
        ctx.strokeRect(8 + i*60, 36, 54, 24);
        ctx.fillStyle = "#fff";
        ctx.font = "14px sans-serif";
        ctx.fillText(s, 14 + i*60, 53);
      });
      ctx.restore();
    }

    // --- Match Logic (same as backup, with special fix) ---
    function getCell(e) {
      const r = canvas.getBoundingClientRect();
      const y = Math.floor((e.clientY - r.top - TOPBAR_HEIGHT) / CELL_SIZE);
      return { x: Math.floor((e.clientX - r.left) / CELL_SIZE), y };
    }
    function isAdj(a,b) { return Math.abs(a.x-b.x)+Math.abs(a.y-b.y)===1; }

    function getGroups() {
      const groups = [];
      // horizontal
      for (let y = 0; y < GRID_SIZE; y++) {
        let run = [{x:0,y}];
        for (let x = 1; x < GRID_SIZE; x++) {
          if (grid[y][x].color === grid[y][x-1].color) run.push({x,y});
          else { if(run.length>=3) groups.push({positions:[...run],orient:'h'}); run=[{x,y}]; }
        }
        if(run.length>=3) groups.push({positions:[...run],orient:'h'});
      }
      // vertical
      for (let x = 0; x < GRID_SIZE; x++) {
        let run = [{x,y:0}];
        for (let y = 1; y < GRID_SIZE; y++) {
          if (grid[y][x].color === grid[y-1][x].color) run.push({x,y});
          else { if(run.length>=3) groups.push({positions:[...run],orient:'v'}); run=[{x,y}]; }
        }
        if(run.length>=3) groups.push({positions:[...run],orient:'v'});
      }
      return groups;
    }

    function markMatchesForAnimationAndSpecials(runs, movedTiles = []) {
      // Helper to get Tile at position
      const tileAt = (p) => grid[p.y][p.x];
      let specialPlaced = false;

      // 6 in line => color bomb
      const st6 = runs.find(g => (g.orient === 'h' || g.orient === 'v') && g.positions.length >= 6);
      if (st6) {
        let tPos = st6.positions.find(p => movedTiles.some(m => m.x === p.x && m.y === p.y));
        let t = tPos ? tileAt(tPos) : tileAt(st6.positions[0]);
        t.special = 'color';
        st6.positions.forEach(p => { if (tileAt(p) !== t) grid[p.y][p.x].matching = true; });
        specialPlaced = true;
      }

      // 5 (line or T/L shape) => bomb
      if (!specialPlaced) {
        let bombRun = runs.find(g => g.positions.length === 5);
        if (!bombRun) {
          for (let i = 0; i < runs.length && !bombRun; i++) {
            for (let j = i + 1; j < runs.length && !bombRun; j++) {
              if (runs[i].orient !== runs[j].orient) {
                const ov = runs[i].positions.find(p => runs[j].positions.some(q => q.x === p.x && q.y === p.y));
                if (ov) {
                  const merged = [...new Set([...runs[i].positions, ...runs[j].positions].map(p => `${p.x},${p.y}`))]
                    .map(s => ({ x: +s.split(',')[0], y: +s.split(',')[1] }));
                  if (merged.length >= 5) {
                    bombRun = { positions: merged };
                  }
                }
              }
            }
          }
        }
        if (bombRun) {
          let tPos = bombRun.positions.find(p => movedTiles.some(m => m.x === p.x && m.y === p.y));
          let t = tPos ? tileAt(tPos) : tileAt(bombRun.positions[0]);
          t.special = 'bomb';
          bombRun.positions.forEach(p => { if (tileAt(p) !== t) grid[p.y][p.x].matching = true; });
          specialPlaced = true;
        }
      }

      // 4 in line => line special
      if (!specialPlaced) {
        const r4 = runs.find(g => g.positions.length === 4);
        if (r4) {
          let tPos = r4.positions.find(p => movedTiles.some(m => m.x === p.x && m.y === p.y));
          let t = tPos ? tileAt(tPos) : tileAt(r4.positions[0]);
          t.special = r4.orient === 'h' ? 'horizontal' : 'vertical';
          r4.positions.forEach(p => { if (tileAt(p) !== t) grid[p.y][p.x].matching = true; });
          specialPlaced = true;
        }
      }

      // normal clear for 3+
      if (!specialPlaced) {
        runs.forEach(g => g.positions.forEach(p => grid[p.y][p.x].matching = true));
      }
    }

    // SPECIAL TILE EFFECTS
function triggerSpecial(tile) {
  if (tile.triggered) return;   // <--- Already handled!
  tile.triggered = true;
  combo++;
  const type = tile.special;
  tile.matching = true;    // animate special tile itself
  tile.animProgress = 0;
  if (type === 'horizontal') {
    for (let x = 0; x < GRID_SIZE; x++) {
      let t = grid[tile.y][x];
      if (t && !t.matching && t !== tile) {
        if (t.special && !t.triggered && !specialsToTrigger.includes(t)) specialsToTrigger.push(t);
        t.matching = true;
        t.animProgress = 0;
        score += combo;
      }
    }
  } else if (type === 'vertical') {
    for (let y = 0; y < GRID_SIZE; y++) {
      let t = grid[y][tile.x];
      if (t && !t.matching && t !== tile) {
        if (t.special && !t.triggered && !specialsToTrigger.includes(t)) specialsToTrigger.push(t);
        t.matching = true;
        t.animProgress = 0;
        score += combo;
      }
    }
  } else if (type === 'bomb') {
    for (let dy = -2; dy <= 2; dy++) for (let dx = -2; dx <= 2; dx++) {
      const X = tile.x + dx, Y = tile.y + dy;
      let t = grid[Y]?.[X];
      if (t && !t.matching && t !== tile) {
        if (t.special && !t.triggered && !specialsToTrigger.includes(t)) specialsToTrigger.push(t);
        t.matching = true;
        t.animProgress = 0;
        score += combo;
      }
    }
  } else if (type === 'color') {
    const c = tile.color;
    for (let y = 0; y < GRID_SIZE; y++) for (let x = 0; x < GRID_SIZE; x++) {
      let t = grid[y][x];
      if (t.color === c && !t.matching && t !== tile) {
        if (t.special && !t.triggered && !specialsToTrigger.includes(t)) specialsToTrigger.push(t);
        t.matching = true;
        t.animProgress = 0;
        score += combo;
      }
    }
  }
}



    function resetPos() { grid.flat().forEach(t=>{t.px=t.x*CELL_SIZE; t.py=t.y*CELL_SIZE+TOPBAR_HEIGHT;}); }

    // Swap logic
    function startSwap(a,b) {
      swapState = { aTile: grid[a.y][a.x], bTile: grid[b.y][b.x], a, b,
        progress:0, rev:false, dir:(b.x!==a.x?'horizontal':'vertical') };
      animating = true;
      requestAnimationFrame(swapStep);
    }

    function swapStep() {
      const s = swapState;
      s.progress = Math.min(s.progress + SWAP_SPEED, 1);
      const ax = s.a.x * CELL_SIZE, ay = s.a.y * CELL_SIZE + TOPBAR_HEIGHT;
      const bx = s.b.x * CELL_SIZE, by = s.b.y * CELL_SIZE + TOPBAR_HEIGHT;
      s.aTile.px = ax + (bx - ax) * s.progress;
      s.aTile.py = ay + (by - ay) * s.progress;
      s.bTile.px = bx + (ax - bx) * s.progress;
      s.bTile.py = by + (ay - by) * s.progress;
      draw();
      if (s.progress < 1) return requestAnimationFrame(swapStep);

      // commit colors
      [s.aTile.color, s.bTile.color] = [s.bTile.color, s.aTile.color];

      // detect runs
      const runs = getGroups();
      if (!runs.length) return requestAnimationFrame(reverseSwap);

      combo++;
      markMatchesForAnimationAndSpecials(runs, [{ x: s.a.x, y: s.a.y }, { x: s.b.x, y: s.b.y }]);
      runs.forEach(g => {
        const len = g.positions.length;
        const pts = len >= 6 ? 5 : len === 5 ? 4 : len === 4 ? 3 : 1;
        score += pts * combo;
      });

      resetPos(); swapState = null;
      requestAnimationFrame(matchStep);
    }

    function reverseSwap() {
      const s = swapState;
      if (!s.rev) { s.rev=true; [s.aTile.color,s.bTile.color]=[s.bTile.color,s.aTile.color]; }
      s.progress = Math.max(s.progress - SWAP_SPEED, 0);
      const ax = s.a.x*CELL_SIZE, ay = s.a.y*CELL_SIZE+TOPBAR_HEIGHT;
      const bx = s.b.x*CELL_SIZE, by = s.b.y*CELL_SIZE+TOPBAR_HEIGHT;
      s.aTile.px = ax + (bx-ax)*s.progress;
      s.aTile.py = ay + (by-ay)*s.progress;
      s.bTile.px = bx + (ax-bx)*s.progress;
      s.bTile.py = by + (ay-by)*s.progress;
      draw(); if (s.progress>0) return requestAnimationFrame(reverseSwap);
      resetPos(); swapState=null; animating=false;
    }

    // Match & collapse
    function matchStep() {
      let any = false;
      grid.flat().forEach(t => {
        const r = t.update();
        // If a tile is being removed and it's a special, trigger its effect!
        if (r === 'remove') {
          if (t.special && !specialsToTrigger.includes(t)) {
            specialsToTrigger.push(t);
          }
          t.toRemove = true;
        }
        if (t.matching) any = true;
      });
      draw();

      if (any) {
        requestAnimationFrame(matchStep);
      } else if (specialsToTrigger.length > 0) {
        // Process all specials that need to trigger (chain reactions)
        let queue = specialsToTrigger.slice();
        specialsToTrigger.length = 0;
        queue.forEach(t => {
          if (grid[t.y] && grid[t.y][t.x] === t && t.special) triggerSpecial(t);
        });
        requestAnimationFrame(matchStep);
      } else {
        cleanup();
      }
    }

    function cleanup() {
      for (let y=0; y<GRID_SIZE; y++) for (let x=0; x<GRID_SIZE; x++) if (grid[y][x]?.toRemove) grid[y][x]=null;
      collapse();
    }
    function collapse() {
  for (let x=0; x<GRID_SIZE; x++) {
    const col=[];
    for (let y=GRID_SIZE-1; y>=0; y--) if (grid[y][x]) col.push(grid[y][x]);
    const miss = GRID_SIZE - col.length;
    for (let i=0; i<miss; i++) col.push(new Tile(randomColor(), x, -1));
    for (let y=GRID_SIZE-1; y>=0; y--) {
      const t = col[GRID_SIZE-1-y];
      t.x = x;
      t.y = y;
      t.targetPy = y * CELL_SIZE + TOPBAR_HEIGHT;
      t.matching = false;
      t.toRemove = false;
      t.animProgress = 0;
      t.scale = 1;
      t.alpha = 1;
      t.triggered = false; // <-- THIS LINE resets it!
      grid[y][x] = t;
    }
  }
  requestAnimationFrame(fall);
}

    function fall() {
      let moving = false;
      grid.flat().forEach(t => { if (t.update() || t.py < t.targetPy) moving = true; });
      draw();
      if (moving) {
        requestAnimationFrame(fall);
      } else {
        const g = getGroups();
        if (g.length) {
          markMatchesForAnimationAndSpecials(g, []);
          requestAnimationFrame(matchStep);
        } else {
          animating = false; combo = 0;
        }
      }
    }

    // Interactions
    canvas.addEventListener('mousedown', e => {
      if (debugMode && debugSelector) return;
      if (animating || timeUp) return;
      const c = getCell(e);
      if (c.y < 0 || c.y >= GRID_SIZE || c.x < 0 || c.x >= GRID_SIZE) return;
      dragStart = c;
    });
    canvas.addEventListener('mousemove', e => {
      if (debugMode && debugSelector) return;
      if (!dragStart || animating || swapState || timeUp) return;
      const c = getCell(e);
      if (isAdj(dragStart, c)) { startSwap(dragStart, c); dragStart = null; }
    });
    canvas.addEventListener('mouseup', () => { dragStart = null; });

    // Click to activate special
    canvas.addEventListener('click', e => {
      if (debugMode && debugSelector) return;
      if (animating || timeUp) return;
      const c = getCell(e);
      const t = grid[c.y]?.[c.x];
      if (t && t.special) {
        animating = true; combo = 1; triggerSpecial(t); requestAnimationFrame(matchStep);
      }
    });

    // Debug contextmenu
    canvas.addEventListener('contextmenu', e => {
      if (!debugMode) return;
      e.preventDefault();
      const cell = getCell(e);
      if (cell.x < 0 || cell.x >= GRID_SIZE || cell.y < 0 || cell.y >= GRID_SIZE) return;
      debugSelector = {
        x: cell.x,
        y: cell.y
      };
      draw();
    });

    canvas.addEventListener('mousedown', e => {
      if (!debugMode || !debugSelector) return;
      const mx = e.offsetX, my = e.offsetY;
      // Color buttons
      for (let i = 0; i < COLORS.length; i++) {
        if (mx >= 8 + i * 42 && mx <= 44 + i * 42 && my >= 4 && my <= 28) {
          grid[debugSelector.y][debugSelector.x].color = COLORS[i];
          grid[debugSelector.y][debugSelector.x].special = null;
          debugSelector = null;
          draw(); return;
        }
      }
      // Special buttons
      const specials = ['none', 'horizontal', 'vertical', 'bomb', 'color'];
      for (let i = 0; i < specials.length; i++) {
        if (mx >= 8 + i * 60 && mx <= 62 + i * 60 && my >= 36 && my <= 60) {
          if (specials[i] === 'none') grid[debugSelector.y][debugSelector.x].special = null;
          else grid[debugSelector.y][debugSelector.x].special = specials[i];
          debugSelector = null;
          draw(); return;
        }
      }
      debugSelector = null;
      draw();
    }, true);

    // Toggle debug with D
    window.addEventListener('keydown', e => {
      if (e.key === 'd' || e.key === 'D') {
        debugMode = !debugMode;
        debugSelector = null;
        draw();
      }
      if ((e.key === 'r' || e.key === 'R') && timeUp) {
        startGame();
      }
    });

    resetBtn.onclick = startGame;

    startGame();
  </script>
</body>
</html>
