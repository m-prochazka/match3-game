<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=600, initial-scale=1.0" />
  <title>Match-3 (Color Bomb fix)</title>
  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0; display: flex; flex-direction: column; align-items: center;
      min-height: 100vh; background: #222; font-family: system-ui, -apple-system, Segoe UI, Arial, sans-serif;
    }
    .hud-bar {
      width: 600px; display: flex; justify-content: space-between; gap: 8px; margin: 14px 0 6px;
    }
    canvas { background: #333; border-radius: 16px; box-shadow: 0 4px 32px #000a; display: block; }
    button {
      font-weight: 700; font-size: 14px; background: #444; color: #fff;
      padding: 8px 14px; border: none; border-radius: 999px; cursor: pointer;
    }
    #gameWrapper { position: relative; }
  </style>
</head>
<body>
  <div class="hud-bar">
    <div style="display:flex; gap:8px;">
      <button id="restartBtn">Restart</button>
      <button id="pauseBtn">Pause</button>
    </div>
    <div style="display:flex; gap:8px;">
      <button id="debugBtn">Debug</button>
    </div>
  </div>

  <div id="gameWrapper">
    <canvas id="gameCanvas" width="600" height="700"></canvas>
  </div>

  <script>
    // --- Config ---
    const GRID_SIZE = 10;
    const TOPBAR_HEIGHT = 60;
    const CELL_SIZE = 60;
    const CANVAS_W = CELL_SIZE * GRID_SIZE;
    const CANVAS_H = TOPBAR_HEIGHT + CELL_SIZE * GRID_SIZE;
    const COLORS = ['#e74c3c', '#f39c12', '#f1c40f', '#2ecc71', '#3498db', '#9b59b6'];
    const FALL_SPEED = 8, MATCH_ANIM_SPEED = 0.08, SWAP_SPEED = 0.20;

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const restartBtn = document.getElementById('restartBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const debugBtn = document.getElementById('debugBtn');

    // --- State ---
    let grid = [];
    let animating = false;
    let dragStart = null;
    let swapState = null;
    let specialsToTrigger = [];
    let highlightingSpecial = false;

    let score = 0;
    let bestScore = parseInt(localStorage.getItem('bestScore') || '0', 10);
    let combo = 0;

    let timer = 60;
    let timerInterval = null;
    let timeUp = false;

    // Flow
    let hasStarted = false;
    let isPaused = false;
    let countdown = 0;
    let countdownStart = 0;

    // Debug / FX
    let debugMode = false;
    let whiteFlashes = [];
    let lastFrameTime = performance.now();

    // --- Graphics (optional images; we fall back to shapes if missing) ---
    const tileImages = [];
    for (let i = 0; i < COLORS.length; i++) {
      const img = new Image();
      img.src = `tile_${i}.png`;
      tileImages.push(img);
    }
    const specialImages = {
      horizontal: (()=>{let i=new Image();i.src="special_horizontal.png";return i;})(),
      vertical:   (()=>{let i=new Image();i.src="special_vertical.png";return i;})(),
      bomb:       (()=>{let i=new Image();i.src="special_bomb.png";return i;})(),
      color:      (()=>{let i=new Image();i.src="special_color.png";return i;})(),
    };

    class Tile {
      constructor(color, x, y) {
        this.color = color;
        this.x = x; this.y = y;
        this.px = x * CELL_SIZE; this.py = y * CELL_SIZE + TOPBAR_HEIGHT;
        this.targetPy = this.py;
        this.scale = 1; this.alpha = 1; this.rotation = 0;
        this.matching = false; this.toRemove = false; this.animProgress = 0;
        this.special = null; this.highlight = false; this.triggered = false;
      }
      draw() {
        const size = CELL_SIZE * this.scale;
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.translate(this.px + CELL_SIZE / 2, this.py + CELL_SIZE / 2);
        ctx.rotate(this.rotation);

        let imgDrawn = false;
        if (this.special && specialImages[this.special]?.complete && specialImages[this.special]?.naturalWidth > 0) {
          ctx.drawImage(specialImages[this.special], -size/2, -size/2, size, size);
          imgDrawn = true;
        } else if (!this.special) {
          const colorIdx = COLORS.indexOf(this.color);
          const img = tileImages[colorIdx];
          if (img && img.complete && img.naturalWidth > 0) {
            ctx.drawImage(img, -size/2, -size/2, size, size);
            imgDrawn = true;
          }
        }

        if (!imgDrawn) {
          ctx.fillStyle = this.color;
          ctx.fillRect(-size/2, -size/2, size, size);
          if (this.special) {
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 3;
            if (this.special === 'horizontal') { ctx.beginPath(); ctx.moveTo(-size/2,0); ctx.lineTo(size/2,0); ctx.stroke(); }
            else if (this.special === 'vertical') { ctx.beginPath(); ctx.moveTo(0,-size/2); ctx.lineTo(0,size/2); ctx.stroke(); }
            else if (this.special === 'bomb') { ctx.beginPath(); ctx.arc(0,0,size/4,0,2*Math.PI); ctx.stroke(); }
            else if (this.special === 'color') { ctx.beginPath(); ctx.moveTo(-size/2,-size/2); ctx.lineTo(size/2,size/2); ctx.moveTo(size/2,-size/2); ctx.lineTo(-size/2,size/2); ctx.stroke(); }
          }
        }

        if (this.highlight) {
          ctx.save();
          ctx.lineWidth = 4; ctx.strokeStyle = "#ffeb3b"; ctx.globalAlpha = 0.75;
          ctx.strokeRect(-size/2+2, -size/2+2, size-4, size-4);
          ctx.restore();
        }

        ctx.restore();
      }
      update() {
        if (!swapState && this.py < this.targetPy) {
          this.py = Math.min(this.py + FALL_SPEED, this.targetPy);
        }
        if (this.matching) {
          this.animProgress += MATCH_ANIM_SPEED;
          const t = Math.min(this.animProgress, 1);
          this.scale = 1 + Math.sin(t * Math.PI) * 0.8;
          this.rotation = t * 2 * Math.PI;
          this.alpha = 1 - t;
          if (this.animProgress >= 1) {
            this.matching = false;
            return 'remove';
          }
        }
        return null;
      }
    }

    function randomColor() {
      return COLORS[Math.floor(Math.random() * COLORS.length)];
    }

    // --- Groups (runs) detection: returns [{positions:[{x,y}..], orient:'h'|'v'}...]
    function getGroups() {
      const groups = [];
      // horizontal
      for (let y = 0; y < GRID_SIZE; y++) {
        let run = [{ x: 0, y }];
        for (let x = 1; x < GRID_SIZE; x++) {
          if (grid[y][x].color === grid[y][x - 1].color) run.push({ x, y });
          else { if (run.length >= 3) groups.push({ positions: [...run], orient: 'h' }); run = [{ x, y }]; }
        }
        if (run.length >= 3) groups.push({ positions: [...run], orient: 'h' });
      }
      // vertical
      for (let x = 0; x < GRID_SIZE; x++) {
        let run = [{ x, y: 0 }];
        for (let y = 1; y < GRID_SIZE; y++) {
          if (grid[y][x].color === grid[y - 1][x].color) run.push({ x, y });
          else { if (run.length >= 3) groups.push({ positions: [...run], orient: 'v' }); run = [{ x, y }]; }
        }
        if (run.length >= 3) groups.push({ positions: [...run], orient: 'v' });
      }
      return groups;
    }

    // Helpers for color-bomb detection with specials mixed into a line
    function sameBaseColor(tile, color) {
      // treat striped/bomb tiles as matching the *base* color,
      // but DO NOT count color bombs as a color-bearing tile
      if (!tile) return false;
      if (tile.special === 'color') return false;
      return tile.color === color;
    }
    function measureLineLength(x, y, dx, dy, color) {
      let len = 0, cx = x, cy = y;
      while (cx >= 0 && cx < GRID_SIZE && cy >= 0 && cy < GRID_SIZE) {
        const t = grid[cy][cx];
        if (!sameBaseColor(t, color)) break;
        len++; cx += dx; cy += dy;
      }
      return len;
    }

    // === Single, authoritative matcher ===
    // Priority: 6+ straight => Color Bomb (early return)
    // then L/T shape 5 => Bomb
    // then straight 5 => Bomb
    // then straight 4 => Striped (h/v by orient)
    // else default clear (3+)
    function markMatchesV3(runs, movedTiles = []) {
      const tileAt = (p) => grid[p.y][p.x];
      const isMoved = (p) => movedTiles.some(m => m.x === p.x && m.y === p.y);
      if (!runs.length) return;

      // 1) 6+ straight (horizontal OR vertical) => Color Bomb
      //    use measureLineLength to count through stripes/bombs of the same color
      const straight = runs.filter(g => g.orient === 'h' || g.orient === 'v');
      // choose a candidate cell to measure (prefer a moved cell if it’s inside a straight run)
      let candidate = null, candidateOrient = null;
      for (const g of straight) {
        const mv = g.positions.find(isMoved) || g.positions[Math.floor(g.positions.length/2)];
        // try horizontal measure
        const color = grid[mv.y][mv.x].color;
        const horLen = measureLineLength(mv.x, mv.y, -1, 0, color) + measureLineLength(mv.x+1, mv.y, 1, 0, color);
        const verLen = measureLineLength(mv.x, mv.y, 0, -1, color) + measureLineLength(mv.x, mv.y+1, 0, 1, color);
        if (horLen >= 6) { candidate = mv; candidateOrient = 'h'; break; }
        if (verLen >= 6) { candidate = mv; candidateOrient = 'v'; break; }
      }
      if (candidate) {
        // select pivot: prefer moved & not already special
        let pivot = candidate;
        if (tileAt(pivot).special) {
          const g = straight.find(gr => gr.positions.some(p => p.x === pivot.x && p.y === pivot.y)) || {positions:[pivot]};
          pivot = g.positions.find(p => !tileAt(p).special) || pivot;
        }
        const t = tileAt(pivot);
        t.special = 'color';
        // clear the rest of that measured 6+ line visually
        const color = t.color;
        if (candidateOrient === 'h') {
          // clear entire contiguous horizontal line of that color except pivot
          let cx = pivot.x; // left
          while (cx-1 >= 0 && sameBaseColor(grid[pivot.y][cx-1], color)) cx--;
          while (cx < GRID_SIZE && sameBaseColor(grid[pivot.y][cx], color)) {
            if (!(cx === pivot.x)) grid[pivot.y][cx].matching = true;
            cx++;
          }
        } else {
          // clear entire contiguous vertical line of that color except pivot
          let cy = pivot.y; // up
          while (cy-1 >= 0 && sameBaseColor(grid[cy-1][pivot.x], color)) cy--;
          while (cy < GRID_SIZE && sameBaseColor(grid[cy][pivot.x], color)) {
            if (!(cy === pivot.y)) grid[cy][pivot.x].matching = true;
            cy++;
          }
        }
        return; // stop – nothing can override a color bomb
      }

      // 2) L/T shape 5 => Bomb
      const hRuns = runs.filter(g => g.orient === 'h' && g.positions.length >= 3);
      const vRuns = runs.filter(g => g.orient === 'v' && g.positions.length >= 3);
      for (const h of hRuns) {
        for (const v of vRuns) {
          const ov = h.positions.find(p => v.positions.some(q => q.x === p.x && q.y === p.y));
          if (!ov) continue;
          const uniqMap = new Map();
          [...h.positions, ...v.positions].forEach(p => uniqMap.set(`${p.x},${p.y}`, p));
          const merged = [...uniqMap.values()];
          if (merged.length === 5) {
            let pivot = ov;
            if (tileAt(pivot).special) {
              pivot = merged.find(p => !tileAt(p).special) || ov;
            }
            const t = tileAt(pivot);
            if (!t.special) {
              t.special = 'bomb';
              merged.forEach(p => { if (p.x !== pivot.x || p.y !== pivot.y) grid[p.y][p.x].matching = true; });
            } else {
              merged.forEach(p => { grid[p.y][p.x].matching = true; });
            }
            return;
          }
        }
      }

      // 3) straight 5 => Bomb
      const straight5 = runs.filter(g => g.positions.length === 5);
      if (straight5.length) {
        const sel = straight5.find(g => g.positions.some(isMoved)) || straight5[0];
        let pivot = sel.positions.find(p => isMoved(p) && !tileAt(p).special) ||
                    sel.positions.find(p => !tileAt(p).special) || sel.positions[2];
        const t = tileAt(pivot);
        if (!t.special) {
          t.special = 'bomb';
          sel.positions.forEach(p => { if (p.x !== pivot.x || p.y !== pivot.y) grid[p.y][p.x].matching = true; });
        } else {
          sel.positions.forEach(p => { grid[p.y][p.x].matching = true; });
        }
        return;
      }

      // 4) straight 4 => Striped
      const straight4 = runs.filter(g => g.positions.length === 4);
      if (straight4.length) {
        const sel = straight4.find(g => g.positions.some(isMoved)) || straight4[0];
        let pivot = sel.positions.find(p => isMoved(p) && !tileAt(p).special) ||
                    sel.positions.find(p => !tileAt(p).special) || sel.positions[1];
        const t = tileAt(pivot);
        if (!t.special) {
          t.special = sel.orient === 'h' ? 'horizontal' : 'vertical';
          sel.positions.forEach(p => { if (p.x !== pivot.x || p.y !== pivot.y) grid[p.y][p.x].matching = true; });
        } else {
          sel.positions.forEach(p => { grid[p.y][p.x].matching = true; });
        }
        return;
      }

      // 5) default: clear all 3+
      for (const g of runs) for (const p of g.positions) grid[p.y][p.x].matching = true;
    }

    // Special highlight area and triggers
    function highlightSpecialArea(tile) {
      grid.flat().forEach(t => t.highlight = false);
      const type = tile.special;
      if (type === 'horizontal') {
        for (let x = 0; x < GRID_SIZE; x++) grid[tile.y][x].highlight = true;
      } else if (type === 'vertical') {
        for (let y = 0; y < GRID_SIZE; y++) grid[y][tile.x].highlight = true;
      } else if (type === 'bomb') {
        for (let dy = -1; dy <= 1; dy++) for (let dx = -1; dx <= 1; dx++) {
          const X = tile.x + dx, Y = tile.y + dy;
          if (grid[Y]?.[X]) grid[Y][X].highlight = true;
        }
      } else if (type === 'color') {
        const c = tile.color;
        for (let y = 0; y < GRID_SIZE; y++) for (let x = 0; x < GRID_SIZE; x++) if (grid[y][x].color === c) grid[y][x].highlight = true;
      }
      draw();
    }

    function triggerSpecial(tile) {
      if (tile.triggered || highlightingSpecial) return;
      tile.triggered = true;
      highlightingSpecial = true;
      highlightSpecialArea(tile);

      setTimeout(() => {
        grid.flat().forEach(t => t.highlight = false);
        highlightingSpecial = false;
        tile.matching = true; tile.animProgress = 0;

        const type = tile.special;
        if (type === 'horizontal') {
          for (let x = 0; x < GRID_SIZE; x++) {
            const t = grid[tile.y][x];
            if (t && !t.matching && t !== tile) { if (t.special && !t.triggered && !specialsToTrigger.includes(t)) specialsToTrigger.push(t); t.matching = true; t.animProgress = 0; score++; }
          }
        } else if (type === 'vertical') {
          for (let y = 0; y < GRID_SIZE; y++) {
            const t = grid[y][tile.x];
            if (t && !t.matching && t !== tile) { if (t.special && !t.triggered && !specialsToTrigger.includes(t)) specialsToTrigger.push(t); t.matching = true; t.animProgress = 0; score++; }
          }
        } else if (type === 'bomb') {
          for (let dy = -1; dy <= 1; dy++) for (let dx = -1; dx <= 1; dx++) {
            const X = tile.x + dx, Y = tile.y + dy; const t = grid[Y]?.[X];
            if (t && !t.matching && t !== tile) { if (t.special && !t.triggered && !specialsToTrigger.includes(t)) specialsToTrigger.push(t); t.matching = true; t.animProgress = 0; score++; }
          }
        } else if (type === 'color') {
          const c = tile.color;
          for (let y = 0; y < GRID_SIZE; y++) for (let x = 0; x < GRID_SIZE; x++) {
            const t = grid[y][x];
            if (t.color === c && !t.matching && t !== tile) { if (t.special && !t.triggered && !specialsToTrigger.includes(t)) specialsToTrigger.push(t); t.matching = true; t.animProgress = 0; score++; }
          }
        }
      }, 40);
    }

    // Color-bomb combo helpers (special+color, double color)
    function triggerColorBombCombo(colorBombTile, otherTile) {
      const targetColor = otherTile.color;
      // remove both swapped tiles
      colorBombTile.matching = true; colorBombTile.animProgress = 0; colorBombTile.special = null;
      otherTile.matching = true;     otherTile.animProgress     = 0; otherTile.special     = null;

      // turn all tiles of target color into other's special, then trigger them
      const specialType = otherTile.special;
      const specialTiles = [];
      for (let y = 0; y < GRID_SIZE; y++) for (let x = 0; x < GRID_SIZE; x++) {
        let t = grid[y][x];
        if (t.color === targetColor && t !== colorBombTile && t !== otherTile) {
          if (t.special) { t.triggered = false; specialsToTrigger.push(t); }
          else { t.special = specialType; t.triggered = false; specialTiles.push(t); }
        }
      }
      draw();

      animating = true;
      let i = 0;
      (function triggerNext() {
        if (i >= specialTiles.length) { requestAnimationFrame(matchStep); return; }
        const st = specialTiles[i++]; if (!st || st.matching) { requestAnimationFrame(triggerNext); return; }
        st.highlight = true; draw();
        setTimeout(() => { st.highlight = false; triggerSpecial(st); requestAnimationFrame(triggerNext); }, 40);
      })();
    }

    function triggerDoubleColorBomb(a, b) {
      highlightingSpecial = true; animating = true;
      [a, b].forEach(t => { if (!t) return; t.matching = true; t.animProgress = 0; t.special = null; });

      let row = 0;
      function sweepNextRow() {
        if (row >= GRID_SIZE) { highlightingSpecial = false; requestAnimationFrame(matchStep); return; }
        for (let x = 0; x < GRID_SIZE; x++) { const t = grid[row][x]; if (t) t.highlight = true; }
        draw();
        setTimeout(() => {
          for (let x = 0; x < GRID_SIZE; x++) {
            const t = grid[row][x];
            if (!t || t.matching) continue;
            if (t.special && !t.triggered && !specialsToTrigger.includes(t)) specialsToTrigger.push(t);
            t.matching = true; t.animProgress = 0; score++;
          }
          for (let x = 0; x < GRID_SIZE; x++) { const t = grid[row][x]; if (t) t.highlight = false; }
          draw(); row++; setTimeout(sweepNextRow, 70);
        }, 80);
      }
      setTimeout(sweepNextRow, 60);
    }

    // --- Swap animation and resolution ---
    function startSwap(a, b) {
      if (!hasStarted || isPaused) return;
      swapState = {
        aTile: grid[a.y][a.x], bTile: grid[b.y][b.x],
        a, b, progress: 0, rev: false
      };
      animating = true;
      requestAnimationFrame(swapStep);
    }

    function swapStep() {
      const s = swapState;
      s.progress = Math.min(s.progress + SWAP_SPEED, 1);
      const ax = s.a.x * CELL_SIZE, ay = s.a.y * CELL_SIZE + TOPBAR_HEIGHT;
      const bx = s.b.x * CELL_SIZE, by = s.b.y * CELL_SIZE + TOPBAR_HEIGHT;
      s.aTile.px = ax + (bx - ax) * s.progress; s.aTile.py = ay + (by - ay) * s.progress;
      s.bTile.px = bx + (ax - bx) * s.progress; s.bTile.py = by + (ay - by) * s.progress;
      draw();

      if (s.progress < 1) return requestAnimationFrame(swapStep);

      // color-bomb combos first
      const aTile = s.aTile, bTile = s.bTile;
      if (aTile.special === 'color' && bTile.special === 'color') { triggerDoubleColorBomb(aTile, bTile); resetPos(); swapState = null; return; }
      if (aTile.special === 'color' && bTile.special && bTile.special !== 'color') { triggerColorBombCombo(aTile, bTile); resetPos(); swapState = null; requestAnimationFrame(matchStep); return; }
      if (bTile.special === 'color' && aTile.special && aTile.special !== 'color') { triggerColorBombCombo(bTile, aTile); resetPos(); swapState = null; requestAnimationFrame(matchStep); return; }

      // standard swap: swap colors only (specials keep their type & color)
      [s.aTile.color, s.bTile.color] = [s.bTile.color, s.aTile.color];
      const runs = getGroups();

      if (!runs.length) return requestAnimationFrame(reverseSwap);

      // resolve matches
      combo++; // scoring simplified
      markMatchesV3(runs, [{ x: s.a.x, y: s.a.y }, { x: s.b.x, y: s.b.y }]);
      runs.forEach(g => { const len = g.positions.length; const pts = len >= 6 ? 100 : len === 5 ? 60 : len === 4 ? 30 : 10; score += pts + combo; });

      resetPos(); swapState = null;
      requestAnimationFrame(matchStep);
    }

    function reverseSwap() {
      const s = swapState;
      if (!s.rev) {
        s.rev = true;
        [s.aTile.color, s.bTile.color] = [s.bTile.color, s.aTile.color];
      }
      s.progress = Math.max(s.progress - SWAP_SPEED, 0);
      const ax = s.a.x * CELL_SIZE, ay = s.a.y * CELL_SIZE + TOPBAR_HEIGHT;
      const bx = s.b.x * CELL_SIZE, by = s.b.y * CELL_SIZE + TOPBAR_HEIGHT;
      s.aTile.px = ax + (bx - ax) * s.progress; s.aTile.py = ay + (by - ay) * s.progress;
      s.bTile.px = bx + (ax - bx) * s.progress; s.bTile.py = by + (ay - by) * s.progress;
      draw();
      if (s.progress > 0) return requestAnimationFrame(reverseSwap);
      resetPos(); swapState = null; animating = false;
    }

    function resetPos() {
      grid.flat().forEach(t => {
        t.px = t.x * CELL_SIZE; t.py = t.y * CELL_SIZE + TOPBAR_HEIGHT;
        t.rotation = 0; t.scale = 1; t.alpha = 1;
      });
    }

    // --- Match animation loop ---
    function matchStep() {
      if (highlightingSpecial) { draw(); requestAnimationFrame(matchStep); return; }
      let any = false;
      grid.flat().forEach(t => {
        const r = t.update();
        if (r === 'remove') {
          // queue chained specials
          if (t.special && !t.triggered && !specialsToTrigger.includes(t)) {
            specialsToTrigger.push(t);
          }
          t.toRemove = true;
        }
        if (t.matching) any = true;
      });
      draw();

      if (any) {
        requestAnimationFrame(matchStep);
      } else if (specialsToTrigger.length > 0) {
        const q = specialsToTrigger.slice(); specialsToTrigger.length = 0;
        q.forEach(t => { if (grid[t.y] && grid[t.y][t.x] === t && t.special) triggerSpecial(t); });
        requestAnimationFrame(matchStep);
      } else {
        cleanup();
      }
    }

    function cleanup() {
      for (let y = 0; y < GRID_SIZE; y++)
        for (let x = 0; x < GRID_SIZE; x++)
          if (grid[y][x]?.toRemove) grid[y][x] = null;
      collapse();
    }

    function collapse() {
      for (let x = 0; x < GRID_SIZE; x++) {
        const col = [];
        for (let y = GRID_SIZE - 1; y >= 0; y--) if (grid[y][x]) col.push(grid[y][x]);
        const miss = GRID_SIZE - col.length;
        for (let i = 0; i < miss; i++) col.push(new Tile(randomColor(), x, -1));
        for (let y = GRID_SIZE - 1; y >= 0; y--) {
          const t = col[GRID_SIZE - 1 - y];
          t.x = x; t.y = y; t.targetPy = y * CELL_SIZE + TOPBAR_HEIGHT;
          t.matching = false; t.toRemove = false; t.animProgress = 0;
          t.scale = 1; t.alpha = 1; t.triggered = false; t.highlight = false;
          grid[y][x] = t;
        }
      }
      requestAnimationFrame(fall);
    }

    function fall() {
      let moving = false;
      grid.flat().forEach(t => { if (t.update() || t.py < t.targetPy) moving = true; });
      draw();
      if (moving) {
        requestAnimationFrame(fall);
      } else {
        const g = getGroups();
        if (g.length) { combo++; markMatchesV3(g, []); requestAnimationFrame(matchStep); }
        else { animating = false; combo = 0; }
      }
    }

    // --- Input ---
    function getCellFromClient(clientX, clientY) {
      const r = canvas.getBoundingClientRect();
      const x = Math.floor((clientX - r.left) / CELL_SIZE);
      const y = Math.floor((clientY - r.top  - TOPBAR_HEIGHT) / CELL_SIZE);
      return { x, y };
    }
    function isAdj(a, b) { return Math.abs(a.x - b.x) + Math.abs(a.y - b.y) === 1; }

    canvas.addEventListener('pointerdown', (e) => {
      if (animating || timeUp || isPaused || !hasStarted) return;
      const c = getCellFromClient(e.clientX, e.clientY);
      if (c.y < 0 || c.y >= GRID_SIZE || c.x < 0 || c.x >= GRID_SIZE) return;
      dragStart = c;
    });

    canvas.addEventListener('pointermove', (e) => {
      if (!dragStart || animating || swapState || timeUp || isPaused || !hasStarted) return;
      const c = getCellFromClient(e.clientX, e.clientY);
      if (isAdj(dragStart, c)) { startSwap(dragStart, c); dragStart = null; }
    });

    canvas.addEventListener('pointerup', () => { dragStart = null; });

    // Click to activate special
    canvas.addEventListener('click', e => {
      if (animating || timeUp || !hasStarted) return;
      const c = getCellFromClient(e.clientX, e.clientY);
      const t = grid[c.y]?.[c.x];
      if (t && t.special) {
        animating = true; combo = 1; triggerSpecial(t); requestAnimationFrame(matchStep);
      }
    });

    // --- UI ---
    restartBtn.addEventListener('click', () => startGame());
    pauseBtn.addEventListener('click', () => { if (!hasStarted || timeUp) return; isPaused = !isPaused; draw(); });
    debugBtn.addEventListener('click', () => { debugMode = !debugMode; draw(); });

    // --- Draw ---
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const now = performance.now();
      const dt = now - lastFrameTime; lastFrameTime = now;

      // HUD
      ctx.save();
      ctx.globalAlpha = 0.96;
      ctx.fillStyle = "#1a1a1a";
      ctx.fillRect(0,0,canvas.width,TOPBAR_HEIGHT);
      ctx.globalAlpha = 1;

      ctx.font = 'bold 26px Segoe UI, Arial, sans-serif'; ctx.fillStyle = '#fff';
      ctx.textAlign = 'left'; ctx.fillText(`Score: ${score}`, 24, 40);
      ctx.textAlign = 'center'; ctx.fillText(`Combo: x${Math.max(1, combo)}`, CANVAS_W/2, 40);
      ctx.textAlign = 'right'; ctx.fillStyle = timer <= 10 ? '#e74c3c' : '#fff'; ctx.fillText(`Time: ${timer}`, CANVAS_W-24, 40);
      ctx.textAlign = 'left'; ctx.fillStyle = '#9aa'; ctx.font = 'bold 14px Segoe UI'; ctx.fillText(`Best: ${bestScore}`, 24, 58);
      ctx.restore();

      // Tiles
      grid.flat().forEach(t => t.draw());

      // Flashes
      for (let i = whiteFlashes.length-1; i >= 0; i--) {
        const f = whiteFlashes[i];
        f.t += dt;
        const p = Math.min(1, f.t / f.life);
        const a = (p < 0.3) ? (p/0.3) : (1 - (p-0.3)/0.7);
        const x = f.x * CELL_SIZE, y = f.y * CELL_SIZE + TOPBAR_HEIGHT;
        ctx.save(); ctx.globalAlpha = Math.max(0, a) * 0.9; ctx.strokeStyle = "#fff"; ctx.lineWidth = 3;
        ctx.strokeRect(x+2, y+2, CELL_SIZE-4, CELL_SIZE-4); ctx.restore();
        if (f.t >= f.life) whiteFlashes.splice(i,1);
      }

      // Pause overlay
      if (isPaused && !timeUp) {
        ctx.save(); ctx.globalAlpha = 0.85; ctx.fillStyle = "#111";
        ctx.fillRect(0, TOPBAR_HEIGHT, canvas.width, canvas.height - TOPBAR_HEIGHT);
        ctx.globalAlpha = 1; ctx.fillStyle = "#fff"; ctx.textAlign = "center";
        ctx.font = "bold 56px Segoe UI, Arial, sans-serif"; ctx.fillText("Paused", CANVAS_W/2, CANVAS_H/2 - 20);
        ctx.font = "18px Segoe UI"; ctx.fillText("Press Pause to resume", CANVAS_W/2, CANVAS_H/2 + 18);
        ctx.restore();
      }

      // Countdown overlay
      if (!hasStarted && !timeUp && countdown > 0) {
        const elapsed = (performance.now() - countdownStart) / 1000;
        let stage = Math.floor(elapsed);
        let display = 3 - stage;
        if (display <= 0) display = "GO!";
        ctx.save(); ctx.globalAlpha = 0.85; ctx.fillStyle = "#111";
        ctx.fillRect(0, TOPBAR_HEIGHT, canvas.width, canvas.height - TOPBAR_HEIGHT);
        ctx.globalAlpha = 1; ctx.fillStyle = "#fff"; ctx.textAlign = "center";
        ctx.font = "bold 80px Segoe UI, Arial"; ctx.fillText(display, CANVAS_W/2, CANVAS_H/2 + 20);
        ctx.restore();
      }

      // Time up overlay
      if (timeUp) {
        ctx.save(); ctx.globalAlpha = 0.8; ctx.fillStyle = "#111";
        ctx.fillRect(0, TOPBAR_HEIGHT, canvas.width, canvas.height - TOPBAR_HEIGHT);
        ctx.globalAlpha = 1; ctx.fillStyle = "#fff"; ctx.textAlign = "center";
        ctx.font = "bold 56px Segoe UI, Arial, sans-serif"; ctx.fillText("Time's Up!", CANVAS_W / 2, CANVAS_H / 2 - 40);
        ctx.font = "bold 32px Segoe UI, Arial, sans-serif"; ctx.fillText(`Score: ${score}`, CANVAS_W / 2, CANVAS_H / 2 + 10);
        ctx.font = "22px Segoe UI"; ctx.fillText(`Best: ${bestScore}`, CANVAS_W / 2, CANVAS_H / 2 + 42);
        ctx.font = "18px Segoe UI"; ctx.fillText("Press Restart", CANVAS_W / 2, CANVAS_H / 2 + 78);
        ctx.restore();
      }

      if (debugMode) {
        ctx.save(); ctx.fillStyle = '#fff'; ctx.font='12px monospace';
        ctx.fillText('DEBUG ON', 8, 14);
        ctx.restore();
      }
    }

    // --- Flow: start, countdown, timer ---
    function clearInitialMatches() {
      let gs = getGroups();
      while (gs.length) {
        gs.forEach(g => g.positions.forEach(p => grid[p.y][p.x].color = randomColor()));
        gs = getGroups();
      }
    }

    function startTimer() {
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        if (animating || isPaused) return;
        timer--;
        if (timer <= 0) {
          timer = 0; timeUp = true; clearInterval(timerInterval); hasStarted = false;
          if (score > bestScore) { bestScore = score; localStorage.setItem('bestScore', String(bestScore)); }
        }
        draw();
      }, 1000);
    }

    function beginCountdown() {
      countdown = 3;
      countdownStart = performance.now();
      (function tick() {
        if (countdown <= 0 || timeUp) return;
        const elapsed = (performance.now() - countdownStart) / 1000;
        if (elapsed >= 3) {
          countdown = 0; hasStarted = true; startTimer(); draw(); return;
        }
        requestAnimationFrame(tick);
      })();
    }

    function startGame() {
      grid = [];
      score = 0; combo = 0; timeUp = false; isPaused = false; hasStarted = false;
      specialsToTrigger = []; whiteFlashes = [];
      if (timerInterval) clearInterval(timerInterval);
      timer = 60;

      for (let y = 0; y < GRID_SIZE; y++) {
        const row = [];
        for (let x = 0; x < GRID_SIZE; x++) row.push(new Tile(randomColor(), x, y));
        grid.push(row);
      }
      clearInitialMatches();
      beginCountdown();
      draw();
    }

    // Boot
    startGame();
  </script>
</body>
</html>
