<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Match-3 Game</title>
  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0; display: flex; flex-direction: column; align-items: center;
      justify-content: flex-start; min-height: 100vh; background: #222; font-family: system-ui, -apple-system, Segoe UI, Arial, sans-serif;
    }
    #gameWrapper { margin-top: 16px; position: relative; }
    canvas { background: #333; border-radius: 16px; box-shadow: 0 4px 32px #000a; display: block; }

    #resetBtn, .hud-btn {
      margin-top: 20px;
      font-weight: 700; font-size: 18px;
      background: linear-gradient(90deg, #e74c3c 0%, #3498db 100%);
      color: #fff; padding: 10px 24px; border: none; border-radius: 999px;
      box-shadow: 0 2px 16px #0005; cursor: pointer; letter-spacing: 1px;
      transition: transform .07s; outline: none;
    }
    #resetBtn:active, .hud-btn:active { transform: scale(0.97); }

    .hud-bar {
      width: 600px; display: flex; justify-content: space-between; gap: 8px; margin-top: 12px;
    }
    .hud-btn { background: #444; padding: 8px 14px; font-size: 14px; }
    .hud-btn:active { transform: scale(0.98); }

    /* Options drawer */
    #optionsPanel {
      position: absolute; top: 66px; right: 8px; width: 240px; z-index: 5;
      background: #1b1b1d; border: 1px solid #2b2b2e; border-radius: 12px; box-shadow: 0 8px 32px #0009;
      padding: 12px; display: none;
    }
    #optionsPanel h3 { margin: 0 0 8px 0; font-size: 16px; color: #fff; }
    #optionsPanel label { display: flex; align-items: center; gap: 8px; color: #ddd; font-size: 13px; margin: 8px 0; }
    #optionsPanel .row { display: flex; align-items: center; justify-content: space-between; gap: 8px; }
    #optionsPanel select, #optionsPanel input[type="range"] {
      width: 120px; background: #2a2a2e; color: #fff; border: 1px solid #3a3a3e; border-radius: 6px; padding: 3px 6px;
    }
    #optionsPanel .sub { color:#9aa; font-size: 12px; margin-top: 6px; }

    /* Pause overlay buttons (HTML for accessibility) */
    #overlayButtons {
      position: absolute; inset: 0; display: none; align-items: center; justify-content: center; gap: 16px; z-index: 6;
    }
    #overlayButtons button {
      background:#2a2a2e; color:#fff; border:1px solid #3a3a2e; border-radius:10px; padding:10px 16px; cursor:pointer; font-weight:600;
    }
    #overlayButtons button:hover { background:#333; }

    @media (max-width: 620px) {
      .hud-bar { width: 100%; padding: 0 10px; box-sizing: border-box; }
    }
    .tile[data-special] {
      cursor: grab;
    }
    .tile[data-special]:active {
      cursor: grabbing;
    }
    
    /* Timer bonus notification */
    .timer-bonus {
      position: absolute;
      color: #2ecc71;
      font-weight: bold;
      font-size: 18px;
      pointer-events: none;
      z-index: 10;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
      animation: floatUp 1.0s ease-out forwards;
    }
    
    @keyframes floatUp {
      0% { transform: translateY(0); opacity: 1; }
      100% { transform: translateY(-40px); opacity: 0; }
    }
  </style>
</head>
<body>
  <div class="hud-bar">
    <button id="resetBtn">Restart</button>
    <div style="display:flex; gap:8px;">
      <button id="pauseBtn" class="hud-btn">Pause</button>
      <button id="optionsBtn" class="hud-btn">⚙️ Options</button>
    </div>
  </div>

  <div id="gameWrapper">
    <canvas id="gameCanvas" width="600" height="700"></canvas>

    <!-- Options drawer -->
    <div id="optionsPanel">
      <h3>Options</h3>
      <label><input type="checkbox" id="optSfx"> Enable SFX</label>
      <label><input type="checkbox" id="optShake"> Screen Shake</label>

      <div class="row">
        <span>Particles</span>
        <select id="optParticles">
          <option value="low">Low</option>
          <option value="med">Med</option>
          <option value="high">High</option>
        </select>
      </div>

      <label><input type="checkbox" id="optReduce"> Reduce Motion</label>

      <div class="row">
        <span>Volume</span>
        <input type="range" min="0" max="100" value="90" id="optVolume"/>
      </div>
      <div class="sub">Settings are saved automatically.</div>
    </div>

    <!-- Pause overlay HTML buttons -->
    <div id="overlayButtons">
      <button id="resumeBtn">Resume</button>
      <button id="overlayRestartBtn">Restart</button>
    </div>
  </div>

  <script>
    // --- Config ---
    const GRID_SIZE = 10;
    const TOPBAR_HEIGHT = 60;
    const CELL_SIZE = 60;
    const CANVAS_W = CELL_SIZE * GRID_SIZE;
    const CANVAS_H = TOPBAR_HEIGHT + CELL_SIZE * GRID_SIZE;
    const COLORS = ['#e74c3c', '#f39c12', '#ffffff', '#2ecc71', '#3498db', '#9b59b6'];
    const FALL_SPEED = 8, MATCH_ANIM_SPEED = 0.08, SWAP_SPEED = 0.2;

    const canvas = document.getElementById('gameCanvas');
    const resetBtn = document.getElementById('resetBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const optionsBtn = document.getElementById('optionsBtn');
    const optionsPanel = document.getElementById('optionsPanel');
    const overlayButtons = document.getElementById('overlayButtons');
    const resumeBtn = document.getElementById('resumeBtn');
    const overlayRestartBtn = document.getElementById('overlayRestartBtn');

    const optSfx = document.getElementById('optSfx');
    const optShake = document.getElementById('optShake');
    const optParticles = document.getElementById('optParticles');
    const optReduce = document.getElementById('optReduce');
    const optVolume = document.getElementById('optVolume');

    canvas.width = CANVAS_W;
    canvas.height = CANVAS_H;
    const ctx = canvas.getContext('2d');

    // --- Game state ---
    let grid = [];
    let animating = false;
    let dragStart = null;
    let score = 0;
    let bestScore = parseInt(localStorage.getItem('bestScore') || '0', 10);
    let combo = 0;
    let swapState = null;
    let specialsToTrigger = [];
    let timer = 60, timerInterval = null, timeUp = false;
    let highlightingSpecial = false;
    let currentShakeX = 0, currentShakeY = 0;

    // Flow state
    let hasStarted = false;        // round started (after countdown)
    let isPaused = false;          // paused
    let countdown = 0;             // 0=none, >0 counting (3..2..1..Go)
    let countdownStart = 0;
    let countdownRAF = null;
    let lastCountdownStage = null;
    
    // Timer bonus notifications
    let timerBonuses = [];

    // Options
    const DEFAULT_OPTIONS = { sfx: true, shake: true, particles: 'med', reduceMotion: false, volume: 0.9 };
    let OPTIONS = loadOptions();

    function loadOptions() {
      try {
        const raw = localStorage.getItem('match3_options');
        if (!raw) return { ...DEFAULT_OPTIONS };
        const o = JSON.parse(raw);
        return { ...DEFAULT_OPTIONS, ...o };
      } catch { return { ...DEFAULT_OPTIONS }; }
    }
    function saveOptions() { localStorage.setItem('match3_options', JSON.stringify(OPTIONS)); }

    // --- FX helpers
    let globalPulse = 0;       // vignette pulse
    let comboPulse = 0;        // HUD combo flair
    let whiteFlashes = [];     // [{x,y,t,life}]
    let stripedPreview = null; // {type:'h'|'v', idx, start, dur}

    // DEBUG MODE VARS
    let debugMode = false;
    let debugSelector = null;

    // drag vs click fix
    let dragStartTime = 0;
    let dragStartPosition = null;
    let isDrag = false;

    // --- Scoring ---
    const SCORE_TILE = 10;                 // per tile actually removed (increased from 2)
    const SCORE_BONUS_STRIPED = 50;       // when a single striped fires (increased from 30)
    const SCORE_BONUS_BOMB = 75;          // when a wrapped/bomb fires (increased from 45)
    const SCORE_BONUS_COLOR = 150;        // when a color bomb fires (increased from 100)
    const SCORE_BONUS_DOUBLE_STRIPED = 100; // double striped / plus combo (increased from 60)
    const SCORE_BONUS_DOUBLE_COLOR = 500; // color + color (increased from 300)
    const SCORE_BONUS_COLOR_TRIGGER = 250; // More than normal color bomb (increased from 150)
    
    // Timer bonuses
    const TIMER_BONUS_SMALL = 2;          // seconds added for small matches
    const TIMER_BONUS_MEDIUM = 3;         // seconds added for medium matches
    const TIMER_BONUS_LARGE = 5;          // seconds added for large matches
    const TIMER_BONUS_SPECIAL = 7;        // seconds added for special tile activation

    function addScore(n) {
      const mult = 1 + 0.15 * Math.max(0, combo - 1); // +15% per cascade step
      score += Math.floor(n * mult);
    }
    
    function addTime(seconds, x, y) {
      if (!hasStarted || timeUp) return;
      
      timer += seconds;
      if (timer > 99) timer = 99; // Cap at 99 seconds
      
      // Create visual timer bonus notification
      if (x !== undefined && y !== undefined) {
        const bonusX = x * CELL_SIZE + CELL_SIZE / 2;
        const bonusY = TOPBAR_HEIGHT + y * CELL_SIZE + CELL_SIZE / 2;
        timerBonuses.push({
          text: `+${seconds}s`,
          x: bonusX,
          y: bonusY,
          t: 0,
          life: 1000
        });
      }
    }

    // Frame timing
    let lastFrameTime = performance.now();
    let avgDt = 16.67;

    // Screen shake
    let shakeAmp = 0; // pixels
    function addShake(power) { if (!OPTIONS.shake || OPTIONS.reduceMotion) return; shakeAmp = Math.min(shakeAmp + power, 24); }

    function hexToRgb(hex) {
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return m ? [parseInt(m[1], 16), parseInt(m[2], 16), parseInt(m[3], 16)] : [255,255,255];
    }

    // --- Optimized Particle System ---
    const MAX_PARTICLES = 700;
    const PARTICLE_BASE_BUDGET = 240;

    // Single array of particle objects for better memory locality
    let particles = new Array(MAX_PARTICLES);
    let activeParticleCount = 0;

    // Initialize particles
    for (let i = 0; i < MAX_PARTICLES; i++) {
      particles[i] = {
        x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 0,
        size: 0, rotation: 0, isShard: false, r: 0, g: 0, b: 0, active: false
      };
    }

    function spawnParticles(x, y, color, n = 10) {
      if (OPTIONS.reduceMotion || OPTIONS.particles === 'low') n = Math.min(n, 6);
      if (OPTIONS.particles === 'high') n = Math.floor(n * 1.3);
      if (OPTIONS.particles === 'low') n = Math.floor(n * 0.6);

      const comboBoost = combo >= 3 ? 1.2 : 1.0;
      const perfClamp = Math.max(0.3, Math.min(1.0, 16.67 / avgDt));
      let budget = Math.floor(PARTICLE_BASE_BUDGET * perfClamp * comboBoost);

      if (budget <= 0) return;
      n = Math.min(n, budget, MAX_PARTICLES - activeParticleCount);

      const [rr, gg, bb] = hexToRgb(color);

      for (let i = 0; i < n; i++) {
        // Find first inactive particle
        let particle;
        for (let j = 0; j < MAX_PARTICLES; j++) {
          if (!particles[j].active) {
            particle = particles[j];
            break;
          }
        }
        if (!particle) break; // No available particles

        let rx = (Math.random() * 2 - 1);
        let ry = (Math.random() * 2 - 1);
        const mag = Math.hypot(rx, ry) || 1; 
        rx /= mag; 
        ry /= mag;

        const speed = 1.4 + Math.random() * 2.6;
        
        particle.x = x;
        particle.y = y;
        particle.vx = rx * speed;
        particle.vy = ry * speed - 0.6;
        particle.life = 0;
        particle.maxLife = 60 + (Math.random() * 70) | 0;
        particle.size = 1.5 + Math.random() * 2.5;
        particle.isShard = (Math.random() < 0.10);
        particle.rotation = Math.atan2(particle.vy, particle.vx);
        particle.r = rr;
        particle.g = gg;
        particle.b = bb;
        particle.active = true;
        
        activeParticleCount++;
      }
    }

    function updateParticles(dt) {
      const scale = dt > 0 ? (dt / 16.6667) : 1;
      const gravityPerFrame = 0.10;
      const dragPerFrame = 0.985;
      const drag = Math.pow(dragPerFrame, scale);

      for (let i = 0; i < MAX_PARTICLES; i++) {
        const p = particles[i];
        if (!p.active) continue;

        p.life += dt;
        p.x += p.vx * scale;
        p.y += p.vy * scale;
        p.vy += gravityPerFrame * scale;
        p.vx *= drag;

        if (p.life > p.maxLife) {
          p.active = false;
          activeParticleCount--;
        }
      }
    }

    function drawParticles(ctx) {
      for (let i = 0; i < MAX_PARTICLES; i++) {
        const p = particles[i];
        if (!p.active) continue;

        const a = 1 - (p.life / p.maxLife);
        const wBias = 1 - a;
        const r = (p.r * (1 - wBias) + 255 * wBias) | 0;
        const g = (p.g * (1 - wBias) + 255 * wBias) | 0;
        const b = (p.b * (1 - wBias) + 255 * wBias) | 0;

        ctx.globalAlpha = Math.max(0, a);
        ctx.fillStyle = `rgb(${r},${g},${b})`;
        const s = p.size;

        if (p.isShard) {
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rotation);
          ctx.fillRect(-s * 1.5, -0.5, s * 3, 1);
          ctx.restore();
        } else {
          ctx.fillRect(p.x - s * 0.5, p.y - s * 0.5, s, s);
        }
      }
      ctx.globalAlpha = 1;
    }

    // --- SFX (WebAudio) ---
    let ACtx = null, masterGain = null;
    function audioCtx() {
      if (!ACtx) {
        ACtx = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = ACtx.createGain();
        // start silent; ramp to OPTIONS.volume to avoid the first loud pop
        masterGain.gain.value = 0;
        masterGain.connect(ACtx.destination);

        const t0 = ACtx.currentTime;
        const target = (OPTIONS?.volume ?? 0.9);
        masterGain.gain.cancelScheduledValues(t0);
        masterGain.gain.setValueAtTime(0, t0);
        masterGain.gain.linearRampToValueAtTime(target, t0 + 0.25);
      }
      return ACtx;
    }
    function rampToVolume(target = (OPTIONS?.volume ?? 0.9), seconds = 0.15) {
      if (!ACtx || !masterGain) return;
      const t0 = ACtx.currentTime;
      const cur = masterGain.gain.value;
      masterGain.gain.cancelScheduledValues(t0);
      masterGain.gain.setValueAtTime(cur, t0);
      masterGain.gain.linearRampToValueAtTime(target, t0 + seconds);
    }

    function duck(db=-3, dur=0.08) {
      if (!masterGain || !OPTIONS.sfx) return;
      const ctx = ACtx;
      const t0 = ctx.currentTime;
      const cur = masterGain.gain.value;
      const target = Math.pow(10, db/20) * cur;
      masterGain.gain.cancelScheduledValues(t0);
      masterGain.gain.setValueAtTime(cur, t0);
      masterGain.gain.linearRampToValueAtTime(target, t0 + 0.01);
      masterGain.gain.linearRampToValueAtTime(cur, t0 + dur);
    }
    function beep({freq=440, dur=0.08, type='sine', gain=0.04, rand=0}) {
      if (!OPTIONS.sfx) return;
      const ctx = audioCtx();
      const t0 = ctx.currentTime;
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = type;
      const f = freq * (1 + (Math.random() * 2 - 1) * rand);
      o.frequency.setValueAtTime(f, t0);
      g.gain.setValueAtTime(0, t0);
      g.gain.linearRampToValueAtTime(gain, t0 + 0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
      o.connect(g).connect(masterGain || ctx.destination);
      o.start(t0);
      o.stop(t0 + dur + 0.02);
    }
    const SFX = {
      swap:     () => beep({freq: 220, type:'triangle', dur:0.05, gain:0.03, rand:0.02}),
      invalid:  () => beep({freq: 140, type:'sawtooth', dur:0.08, gain:0.025}),
      pop:      () => beep({freq: 660, type:'square', dur:0.04, gain:0.02, rand:0.03}),
      special:  () => { duck(-4, 0.1); beep({freq: 220, type:'sine', dur:0.07, gain:0.04}); setTimeout(()=>beep({freq:440, dur:0.06, gain:0.03, rand:0.01}),40); },
      colorBomb:() => { duck(-5, 0.15); beep({freq: 200, type:'triangle', dur:0.09, gain:0.05}); setTimeout(()=>beep({freq: 800, dur:0.06, gain:0.03, rand:0.02}),80); },
      sweepTick:() => beep({freq: 520, type:'square', dur:0.03, gain:0.02}),
      colorBombTrigger: () => { 
        duck(-6, 0.15); 
        beep({freq: 180, type:'sine', dur:0.12, gain:0.06});
        setTimeout(()=>beep({freq:720, dur:0.08, gain:0.04}), 80);
      },
      countdownStage: (stage) => {
        if (!OPTIONS.sfx) return;
        const freqMap = {3: 392, 2: 349, 1: 330, 0: 880};
        const f = freqMap[stage] ?? 440;
        beep({ freq: f, type: 'sine', dur: 0.08, gain: 0.018, rand: 0.01 });
      },
      timeBonus: () => beep({freq: 784, type:'sine', dur:0.06, gain:0.025, rand:0.01}) // G5 note
    };
    resetBtn.addEventListener('click', () => { try { audioCtx().resume().then(()=>rampToVolume()); } catch {} });
    canvas.addEventListener('pointerdown', () => { try { audioCtx().resume().then(()=>rampToVolume()); } catch {} }, { once:true });

    function roundRect(ctx, x, y, w, h, r) {
      const rr = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y,     x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x,     y + h, rr);
      ctx.arcTo(x,     y + h, x,     y,     rr);
      ctx.arcTo(x,     y,     x + w, y,     rr);
      ctx.closePath();
    }

    // --- Graphics (forest theme) ---

    // Keep your COLORS array as-is for particles/UI; we just map them to themed art by index
    // COLORS order -> art keys:
    // 0:red, 1:orange, 2:yellow, 3:green, 4:blue, 5:purple

    const FOREST_TILE_KEYS = [
      'mushroom_amanita',   // red    (#e74c3c)
      'mushroom_chanterelle', // orange (#f39c12)
      'mushroom_white',  // yellow (#f1c40f)
      'moss',               // green  (#2ecc71)
      'berries_blue',       // blue   (#3498db)
      'mushroom_yellow'       // purple (#9b59b6)
    ];

    // Put your PNGs in /assets/forest/ with these names, sized ~CELL_SIZE and transparent bg:
    // /assets/forest/mushroom_amanita.png
    // /assets/forest/mushroom_chanterelle.png
    // /assets/forest/mushroom_puffball.png
    // /assets/forest/moss.png
    // /assets/forest/berries_blue.png
    // /assets/forest/mushroom_white.png
    //
    // Optional special art (fallbacks to vector if missing):
    // /assets/forest/special_horizontal.png
    // /assets/forest/special_vertical.png
    // /assets/forest/special_bomb.png
    // /assets/forest/special_color.png

    // Background
    const bgImage = new Image();
    bgImage.src = 'assets/forest/background_forest.png'; // 600x640-ish (board area) is ideal

    // Tile images by color index
    const tileImages = [];
    for (let i = 0; i < FOREST_TILE_KEYS.length; i++) {
      const img = new Image();
      img.src = `assets/forest/${FOREST_TILE_KEYS[i]}.png`;
      tileImages.push(img);
    }

    // Special images (optional). If not present, code draws vector shapes as a fallback.
    const specialImages = {
      horizontal: (()=>{ const i=new Image(); i.src='assets/forest/special_horizontal.png'; return i; })(),
      vertical:   (()=>{ const i=new Image(); i.src='assets/forest/special_vertical.png';   return i; })(),
      bomb:       (()=>{ const i=new Image(); i.src='assets/forest/special_bomb.png';       return i; })(),
      color:      (()=>{ const i=new Image(); i.src='assets/forest/special_color.png';      return i; })(),
    };

    class Tile {
      constructor(color, x, y) {
        this.color = color;
        this.x = x; this.y = y;
        this.px = x * CELL_SIZE; this.py = y * CELL_SIZE + TOPBAR_HEIGHT;
        this.scale = 1; this.alpha = 1; this.rotation = 0;
        this.matching = false; this.toRemove = false; this.animProgress = 0;
        this.targetPy = this.py; this.special = null; this.highlight = false; this.triggered = false;
        this.spawnScale = 1; this.nudgeX = 0; this.nudgeY = 0; this.nudgeT = 0;
      }
      draw() {
        const size = CELL_SIZE * this.scale * this.spawnScale;
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.translate(this.px + CELL_SIZE / 2 + this.nudgeX, this.py + CELL_SIZE / 2 + this.nudgeY);
        ctx.rotate(this.rotation);
        if (this.special) {
          ctx.save();
          ctx.globalAlpha = 0.6 * this.alpha;
          ctx.filter = 'blur(8px)';
          ctx.fillStyle = this.special === 'color' ? '#ffffff' : this.color;
          ctx.beginPath();
          ctx.arc(0, 0, size/2 + 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        let imgDrawn = false;
        if (this.special && specialImages[this.special]?.complete && specialImages[this.special]?.naturalWidth > 0) {
          ctx.drawImage(specialImages[this.special], -size/2, -size/2, size, size); imgDrawn = true;
        } else if (!this.special) {
          const colorIdx = COLORS.indexOf(this.color);
          const img = tileImages[colorIdx];
          if (img && img.complete && img.naturalWidth > 0) { ctx.drawImage(img, -size/2, -size/2, size, size); imgDrawn = true; }
        }
        if (!imgDrawn) {
          ctx.fillStyle = this.color;
          ctx.fillRect(-size / 2, -size / 2, size, size);
          if (this.special) {
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 3;
            if (this.special === 'horizontal') { ctx.beginPath(); ctx.moveTo(-size/2,0); ctx.lineTo(size/2,0); ctx.stroke(); }
            else if (this.special === 'vertical') { ctx.beginPath(); ctx.moveTo(0,-size/2); ctx.lineTo(0,size/2); ctx.stroke(); }
            else if (this.special === 'bomb') { ctx.beginPath(); ctx.arc(0,0,size/4,0,2*Math.PI); ctx.stroke(); }
            else if (this.special === 'color') { ctx.beginPath(); ctx.moveTo(-size/2,-size/2); ctx.lineTo(size/2,size/2); ctx.moveTo(size/2,-size/2); ctx.lineTo(-size/2,size/2); ctx.stroke(); }
          }
        }
        if (this.highlight) {
          ctx.save(); ctx.lineWidth = 5; ctx.strokeStyle = "#ffeb3b"; ctx.globalAlpha = 0.75;
          ctx.strokeRect(-size/2+2, -size/2+2, size-4, size-4); ctx.restore();
        }
        ctx.restore();
      }
      update(dt=0) {
        if (!swapState && this.py < this.targetPy) { this.py = Math.min(this.py + FALL_SPEED, this.targetPy); }
        if (this.spawnScale < 1) { this.spawnScale = Math.min(1, this.spawnScale + 0.12); }
        if (this.nudgeT > 0) {
          this.nudgeT -= dt; this.nudgeX *= 0.86; this.nudgeY *= 0.86; if (this.nudgeT <= 0) { this.nudgeX = this.nudgeY = 0; }
        }
        if (this.matching) {
          this.animProgress += MATCH_ANIM_SPEED;
          const t = Math.min(this.animProgress, 1);
          this.scale = 1 + Math.sin(t * Math.PI) * 0.8;
          this.rotation = t * 2 * Math.PI; this.alpha = 1 - t;
          if (this.animProgress >= 1) { this.matching = false; return 'remove'; }
        }
        return null;
      }
    }

    function isMatchableTile(t) { return !!(t && !t.toRemove); }
    function sameBaseColor(t, color) {
      // Special tiles (except color bomb) don't match with normal colors
      if (t && t.special && t.special !== 'color') return false;
      return isMatchableTile(t) && t.color === color;
    }

    /** Measure the full contiguous line length through (x,y) along orient ('h'|'v'),
     *  counting striped/bomb tiles by color; only color-bomb breaks the line. */
    function measureLineLength(x, y, orient) {
      const t0 = grid[y]?.[x];
      if (!isMatchableTile(t0)) return 0;

      // Special tiles (except color bomb) don't form lines with normal colors
      if (t0.special && t0.special !== 'color') return 0;
      
      const color = t0.color;
      let len = 1;

      // extend negative direction
      let i = 1;
      while (true) {
        const nx = orient === 'h' ? x - i : x;
        const ny = orient === 'h' ? y : y - i;
        const t = grid[ny]?.[nx];
        if (!sameBaseColor(t, color)) break;
        len++; i++;
      }

      // extend positive direction
      i = 1;
      while (true) {
        const nx = orient === 'h' ? x + i : x;
        const ny = orient === 'h' ? y : y + i;
        const t = grid[ny]?.[nx];
        if (!sameBaseColor(t, color)) break;
        len++; i++;
      }

      return len;
    }

    // Toasts
    const toasts = []; // {text,x,y,t,life}
    function addToast(text, x, y, life=700) { toasts.push({ text, x, y, t: 0, life }); }
    function drawToasts(dt) {
      for (let i = toasts.length-1; i >= 0; i--) {
        const o = toasts[i]; o.t += dt;
        const p = Math.min(1, o.t / o.life);
        const alpha = (p < 0.2) ? (p/0.2) : (1 - Math.max(0, (p-0.7)/0.3));
        const dy = -30 * p;
        ctx.save(); ctx.globalAlpha = Math.max(0, alpha); ctx.fillStyle = '#fff';
        ctx.font = 'bold 18px Segoe UI, Arial'; ctx.textAlign = 'center'; ctx.fillText(o.text, o.x, o.y + dy);
        ctx.restore();
        if (o.t >= o.life) { toasts.splice(i,1); }
      }
    }
    
    // Draw timer bonuses
    function drawTimerBonuses(dt) {
      for (let i = timerBonuses.length-1; i >= 0; i--) {
        const bonus = timerBonuses[i]; 
        bonus.t += dt;
        const p = Math.min(1, bonus.t / bonus.life);
        const alpha = (p < 0.3) ? (p/0.3) : (1 - Math.max(0, (p-0.7)/0.3));
        const dy = -40 * p;
        ctx.save(); 
        ctx.globalAlpha = Math.max(0, alpha); 
        ctx.fillStyle = '#2ecc71';
        ctx.font = 'bold 20px Segoe UI, Arial'; 
        ctx.textAlign = 'center'; 
        ctx.fillText(bonus.text, bonus.x, bonus.y + dy);
        ctx.restore();
        if (bonus.t >= bonus.life) { timerBonuses.splice(i,1); }
      }
    }

    // --- Special Combo Detection ---
    function getSpecialComboType(a, b) {
      const set = new Set([a.special, b.special]);
      if (
        (set.has('horizontal') && set.has('vertical')) ||
        (a.special === 'horizontal' && b.special === 'horizontal') ||
        (a.special === 'vertical' && b.special === 'vertical')
      ) return 'plus';
      if ((set.has('bomb') && set.has('horizontal')) || (set.has('bomb') && set.has('vertical'))) {
        return (a.special === 'horizontal' || b.special === 'horizontal') ? 'double_horizontal' : 'double_vertical';
      }
      if (set.has('color') && (set.has('horizontal') || set.has('vertical') || set.has('bomb'))) {
        return (a.special === 'color') ? b.special : a.special;
      }
      return null;
    }

    // Combo handlers (plus/double rows/cols) + color + double color bomb
    function highlightPlusCombo(x, y) {
      for (let y = 0; y < GRID_SIZE; y++) {
        const row = grid[y];
        for (let x = 0; x < GRID_SIZE; x++) {
          const t = row[x];
          if (t) t.highlight = false;
        }
      }
      for (let i = 0; i < GRID_SIZE; i++) { grid[y][i].highlight = true; grid[i][x].highlight = true; }
      draw();
    }
    function triggerPlusCombo(x, y, a, b) {
      highlightPlusCombo(x, y);
      addShake(4); globalPulse = Math.min(1, globalPulse + 0.5);
      highlightingSpecial = true;
      setTimeout(() => {
        for (let y = 0; y < GRID_SIZE; y++) {
          const row = grid[y];
          for (let x = 0; x < GRID_SIZE; x++) {
            const t = row[x];
            if (t) t.highlight = false;
          }
        }
        highlightingSpecial = false;
        [a, b].forEach(pos => { let t = grid[pos.y]?.[pos.x]; if (t) { t.matching = true; t.animProgress = 0; t.special = null; } });
        const alreadyQueued = new Set();
        for (let i = 0; i < GRID_SIZE; i++) {
          let rowT = grid[y][i]; let colT = grid[i][x];
          [rowT, colT].forEach(t => {
            if (t && !t.matching) {
              const key = t.y * 100 + t.x;
              if (!alreadyQueued.has(key)) {
                if (t.special && !t.triggered && !specialsToTrigger.includes(t)) specialsToTrigger.push(t);
                t.matching = true; t.animProgress = 0; score += combo;
                alreadyQueued.add(key);
                if (t.special && t.special !== 'color' && !t.triggered && !specialsToTrigger.includes(t)) {
                  specialsToTrigger.push(t);
                }
                whiteFlashes.push({ x: t.x, y: t.y, t: 0, life: 120 });
                addScore(SCORE_BONUS_DOUBLE_STRIPED);
                addTime(TIMER_BONUS_SPECIAL, t.x, t.y); // Add time bonus
              }
            }
          });
        }
      }, 50);
    }
    function highlightDoubleHorizontalCombo(x, y) {
      for (let y = 0; y < GRID_SIZE; y++) {
        const row = grid[y];
        for (let x = 0; x < GRID_SIZE; x++) {
          const t = row[x];
          if (t) t.highlight = false;
        }
      }
      for (let dy = -1; dy <= 1; dy++) {
        let row = y + dy; if (row >= 0 && row < GRID_SIZE) for (let col = 0; col < GRID_SIZE; col++) grid[row][col].highlight = true;
      }
      draw();
    }
    function triggerDoubleHorizontalCombo(x, y, a, b) {
      highlightDoubleHorizontalCombo(x, y);
      addShake(5); globalPulse = Math.min(1, globalPulse + 0.6);
      highlightingSpecial = true;
      setTimeout(() => {
        for (let y = 0; y < GRID_SIZE; y++) {
          const row = grid[y];
          for (let x = 0; x < GRID_SIZE; x++) {
            const t = row[x];
            if (t) t.highlight = false;
          }
        }
        highlightingSpecial = false;
        [a, b].forEach(pos => { let t = grid[pos.y]?.[pos.x]; if (t) { t.matching = true; t.animProgress = 0; t.special = null; } });
        for (let dy = -1; dy <= 1; dy++) {
          let row = y + dy;
          if (row >= 0 && row < GRID_SIZE) {
            for (let col = 0; col < GRID_SIZE; col++) {
              let t = grid[row][col];
              if (t && !t.matching) {
                if (t.special && !t.triggered && !specialsToTrigger.includes(t)) specialsToTrigger.push(t);
                t.matching = true; t.animProgress = 0; score += combo; whiteFlashes.push({ x: t.x, y: t.y, t: 0, life: 120 });
                if (t.special && t.special !== 'color' && !t.triggered && !specialsToTrigger.includes(t)) {
                  specialsToTrigger.push(t);
                  addScore(SCORE_BONUS_DOUBLE_STRIPED);
                  addTime(TIMER_BONUS_SPECIAL, t.x, t.y); // Add time bonus
                }
              }
            }
          }
        }
      }, 50);
    }
    function highlightDoubleVerticalCombo(x, y) {
      for (let y = 0; y < GRID_SIZE; y++) {
        const row = grid[y];
        for (let x = 0; x < GRID_SIZE; x++) {
          const t = row[x];
          if (t) t.highlight = false;
        }
      }
      for (let dx = -1; dx <= 1; dx++) {
        let col = x + dx; if (col >= 0 && col < GRID_SIZE) for (let row = 0; row < GRID_SIZE; row++) grid[row][col].highlight = true;
      }
      draw();
    }
    function triggerDoubleVerticalCombo(x, y, a, b) {
      highlightDoubleVerticalCombo(x, y);
      addShake(5); globalPulse = Math.min(1, globalPulse + 0.6);
      highlightingSpecial = true;
      setTimeout(() => {
        for (let y = 0; y < GRID_SIZE; y++) {
          const row = grid[y];
          for (let x = 0; x < GRID_SIZE; x++) {
            const t = row[x];
            if (t) t.highlight = false;
            }
          }
        highlightingSpecial = false;
        [a, b].forEach(pos => { let t = grid[pos.y]?.[pos.x]; if (t) { t.matching = true; t.animProgress = 0; t.special = null; } });
        for (let dx = -1; dx <= 1; dx++) {
          let col = x + dx;
          if (col >= 0 && col < GRID_SIZE) {
            for (let row = 0; row < GRID_SIZE; row++) {
              let t = grid[row][col];
              if (t && !t.matching) {
                if (t.special && !t.triggered && !specialsToTrigger.includes(t)) specialsToTrigger.push(t);
                t.matching = true; t.animProgress = 0; score += combo; whiteFlashes.push({ x: t.x, y: t.y, t: 0, life: 120 });
                if (t.special && t.special !== 'color' && !t.triggered && !specialsToTrigger.includes(t)) {
                  specialsToTrigger.push(t);
                  addScore(SCORE_BONUS_DOUBLE_STRIPED);
                  addTime(TIMER_BONUS_SPECIAL, t.x, t.y); // Add time bonus
                }
              }
            }
          }
        }
      }, 50);
    }
    function triggerColorBombByColor(colorBombTile, targetColor) {
      colorBombTile.matching = true;
      colorBombTile.animProgress = 0;
      SFX.colorBombTrigger();
      addScore(SCORE_BONUS_COLOR_TRIGGER);
      
      // Highlight all tiles of the target color
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const t = grid[y][x];
          if (t && t.color === targetColor) {
            t.highlight = true;
          }
        }
      }
      
      draw();

      const midX = colorBombTile.x * CELL_SIZE + CELL_SIZE/2;
      const midY = TOPBAR_HEIGHT + colorBombTile.y * CELL_SIZE + CELL_SIZE/2;
      spawnParticles(midX, midY, targetColor, 30); // More particles for bigger effect
      
      setTimeout(() => {
        // Remove highlight and mark matching
        for (let y = 0; y < GRID_SIZE; y++) {
          for (let x = 0; x < GRID_SIZE; x++) {
            const t = grid[y][x];
            if (t && t.color === targetColor) {
              t.highlight = false;
              if (!t.matching && t !== colorBombTile) {
                t.matching = true;
                t.animProgress = 0;
                if (t.special && !t.triggered && !specialsToTrigger.includes(t)) {
                  specialsToTrigger.push(t);
                }
                whiteFlashes.push({ x: t.x, y: t.y, t: 0, life: 120 });
                addScore(SCORE_BONUS_COLOR);
                addTime(TIMER_BONUS_LARGE, t.x, t.y); // Add time bonus
              }
            }
          }
        }
        
        // Start match animation
        requestAnimationFrame(matchStep);
      }, 300);
    }
    // Color Bomb + Color Bomb => sweep entire board row-by-row
    function triggerDoubleColorBomb(tileA, tileB) {
      highlightingSpecial = true; animating = true;
      SFX.colorBomb(); addShake(8); globalPulse = 1;
      [tileA, tileB].forEach(t => { if (!t) return; t.matching = true; t.animProgress = 0; t.special = null; });

      let row = 0;
      function sweepNextRow() {
        if (row >= GRID_SIZE) { highlightingSpecial = false; requestAnimationFrame(matchStep); return; }
        for (let x = 0; x < GRID_SIZE; x++) { const t = grid[row][x]; if (t) t.highlight = true; }
        draw(); SFX.sweepTick(); addShake(2);
        setTimeout(() => {
          for (let x = 0; x < GRID_SIZE; x++) {
            const t = grid[row][x];
            if (!t || t.matching) continue;
            if (t.special && !t.triggered && !specialsToTrigger.includes(t)) specialsToTrigger.push(t);
            t.matching = true; t.animProgress = 0; whiteFlashes.push({ x: t.x, y: t.y, t: 0, life: 120 }); score += Math.max(1, combo + 1);
            if (x === (GRID_SIZE >> 1)) {
              const midX = x * CELL_SIZE + CELL_SIZE * 0.5;
              const midY = TOPBAR_HEIGHT + row * CELL_SIZE + CELL_SIZE * 0.5;
              spawnParticles(midX, midY, '#ffffff', 24);
              addScore(SCORE_BONUS_DOUBLE_COLOR);
              addTime(TIMER_BONUS_SPECIAL, x, row); // Add time bonus
            }
          }
          for (let x = 0; x < GRID_SIZE; x++) { const t = grid[row][x]; if (t) t.highlight = false; }
          draw(); row++; setTimeout(sweepNextRow, 70);
        }, 90);
      }
      setTimeout(sweepNextRow, 60);
    }

    // --- Color Bomb Combo: spread and sequentially trigger ---
    function highlightColorBombCombo(color) {
      for (let y = 0; y < GRID_SIZE; y++) {
        const row = grid[y];
        for (let x = 0; x < GRID_SIZE; x++) {
          const t = row[x];
          if (t) t.highlight = false;
        }
      }
      for (let y = 0; y < GRID_SIZE; y++) for (let x = 0; x < GRID_SIZE; x++) if (grid[y][x].color === color) grid[y][x].highlight = true;
      draw();
    }
    function triggerColorBombCombo(colorBombTile, otherTile) {
      const targetColor = otherTile.color; const specialType = otherTile.special;
      highlightColorBombCombo(targetColor); SFX.colorBomb(); globalPulse = Math.min(1, globalPulse + 0.7);
      highlightingSpecial = true;
      setTimeout(() => {
        for (let y = 0; y < GRID_SIZE; y++) {
          const row = grid[y];
          for (let x = 0; x < GRID_SIZE; x++) {
            const t = row[x];
            if (t) t.highlight = false;
          }
        } highlightingSpecial = false;
        colorBombTile.matching = true; colorBombTile.animProgress = 0; colorBombTile.special = null;
        otherTile.matching = true;     otherTile.animProgress     = 0; otherTile.special     = null;

        let specialTiles = [];
        for (let y = 0; y < GRID_SIZE; y++) for (let x = 0; x < GRID_SIZE; x++) {
          let t = grid[y][x];
          if (t.color === targetColor && t !== colorBombTile && t !== otherTile) {
            if (t.special) {
              t.triggered = false; specialsToTrigger.push(t);
            } else {
              t.special = specialType; t.triggered = false; specialTiles.push(t); onSpecialCreated(t);
            }
          }
        }
        draw();

        animating = true; let i = 0;
        function triggerNextSpecial() {
          if (i >= specialTiles.length) { requestAnimationFrame(matchStep); return; }
          if (highlightingSpecial) { setTimeout(triggerNextSpecial, 12); return; }
          const st = specialTiles[i++]; if (!st || st.matching) { setTimeout(triggerNextSpecial, 0); return; }
          st.highlight = true; draw();
          setTimeout(() => { st.highlight = false; triggerSpecial(st); setTimeout(triggerNextSpecial, 60); }, 40);
        }
        setTimeout(triggerNextSpecial, 60);
      }, 120);
    }

    // --- Init / flow ---
    function startGame() {
      grid = []; score = 0; combo = 0; comboPulse = 0; timeUp = false; hasStarted = false; isPaused = false;
      specialsToTrigger = []; whiteFlashes = []; stripedPreview = null; globalPulse = 0;
      timerBonuses = []; // Clear timer bonuses
      if (timerInterval) clearInterval(timerInterval);
      timer = 60;

      for (let y = 0; y < GRID_SIZE; y++) {
        const row = [];
        for (let x = 0; x < GRID_SIZE; x++) row.push(new Tile(randomColor(), x, y));
        grid.push(row);
      }
      clearInitialMatches();
      while (!hasAnyLegalMove()) reshuffleBoard();  
      beginCountdown();
      draw();
      resetBtn.textContent = "Restart";
    }

    function countdownTick() {
      if (countdown > 0 && !hasStarted && !timeUp) {
        const now = performance.now();
        const elapsed = (now - countdownStart) / 1000;
        let stage = 3 - Math.floor(elapsed); // 3..2..1..0
        if (stage < 0) stage = 0;

        if (lastCountdownStage !== stage) {
          lastCountdownStage = stage;
          SFX.countdownStage(stage);
        }

        draw();

        if (elapsed >= 3) {
          countdown = 0;
          hasStarted = true;
          lastCountdownStage = null;
          try { audioCtx().resume().then(()=>rampToVolume()); } catch {}
          startTimer();
          draw();
          return;
        }
        countdownRAF = requestAnimationFrame(countdownTick);
      } else if (countdownRAF) {
        cancelAnimationFrame(countdownRAF);
        countdownRAF = null;
      }
    }

    function beginCountdown() {
      countdown = 3;
      lastCountdownStage = null;
      countdownStart = performance.now();
      try { audioCtx().resume().then(()=>rampToVolume()); } catch {}
      countdownTick();
    }

    function startTimer() {
      if (timerInterval) clearInterval(timerInterval);
      hasStarted = true;
      timerInterval = setInterval(() => {
        if (animating || isPaused) return;
        timer--;
        if (timer <= 0) { timer = 0; timeUp = true; clearInterval(timerInterval); hasStarted = false; updateBest(); }
        draw();
      }, 1000);
    }
    function updateBest() {
      if (score > bestScore) {
        bestScore = score; localStorage.setItem('bestScore', String(bestScore));
      }
    }

    function randomColor() { return COLORS[Math.floor(Math.random() * COLORS.length)]; }
    function clearInitialMatches() {
      let gs = getGroups();
      while (gs.length) {
        gs.forEach(g => g.positions.forEach(p => grid[p.y][p.x].color = randomColor()));
        gs = getGroups();
      }
    }

    // --- Drawing / UI ---
    function draw() {
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const now = performance.now();
      const dt = now - lastFrameTime; lastFrameTime = now;
      avgDt = avgDt * 0.9 + dt * 0.1;

      // HUD (no shake)
      ctx.save();
      ctx.globalAlpha = 0.96;
      ctx.fillStyle = "#1a1a1a";
      ctx.fillRect(0,0,canvas.width,TOPBAR_HEIGHT);
      ctx.globalAlpha = 1;

      // Combo pulse anim
      comboPulse = Math.max(0, comboPulse - dt / 140);
      const pulseS = 1 + 0.15 * Math.sin((1 - comboPulse) * Math.PI) * Math.max(0, comboPulse);

      ctx.save();
      ctx.font = `bold 26px Segoe UI, Arial, sans-serif`;
      ctx.fillStyle = '#fff'; ctx.textAlign = 'left';
      ctx.fillText(`Score: ${score}`, 24, 40);

      ctx.textAlign = 'center';
      ctx.save(); ctx.translate(CANVAS_W/2, 40); ctx.scale(pulseS, pulseS);
      ctx.fillStyle = combo > 1 ? '#f6d06f' : '#fff';
      ctx.fillText(`Combo: x${combo>1?combo:1}`, 0, 0);
      ctx.restore();

      ctx.textAlign = 'right';
      ctx.fillStyle = timer <= 10 ? '#e74c3c' : '#fff';
      ctx.fillText(`Time: ${timer}`, CANVAS_W-24, 40);

      // Best score preview
      ctx.textAlign = 'left'; ctx.fillStyle = '#9aa'; ctx.font = 'bold 14px Segoe UI';
      ctx.fillText(`Best: ${bestScore}`, 24, 58);

      ctx.restore();

      // Shake decay
      const decay = Math.pow(0.88, dt / 16.67);
      shakeAmp *= decay;
      const sx = (Math.random() * 2 - 1) * shakeAmp;
      const sy = (Math.random() * 2 - 1) * shakeAmp;
      currentShakeX = sx; currentShakeY = sy;

      ctx.save();
      ctx.translate(sx, sy);

      // Background under playfield
      if (bgImage.complete && bgImage.naturalWidth > 0) {
        // Fill only the playfield (below the HUD/topbar)
        ctx.drawImage(bgImage, 0, TOPBAR_HEIGHT, CANVAS_W, CANVAS_H - TOPBAR_HEIGHT);
        // Add this dark overlay on top of the background:
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; // 50% black overlay
        ctx.fillRect(0, TOPBAR_HEIGHT, CANVAS_W, CANVAS_H - TOPBAR_HEIGHT);
      } else {
        // Make your fallback gradient even darker
        const g = ctx.createLinearGradient(0, TOPBAR_HEIGHT, 0, CANVAS_H);
        g.addColorStop(0, '#0a150a');  // Darker green
        g.addColorStop(1, '#050a05');  // Even darker
        ctx.fillStyle = g;
        ctx.fillRect(0, TOPBAR_HEIGHT, CANVAS_W, CANVAS_H - TOPBAR_HEIGHT);
      }

      // Tiles
      for (let y = 0; y < GRID_SIZE; y++) {
        const row = grid[y];
        for (let x = 0; x < GRID_SIZE; x++) {
          const t = row[x];
          if (!t) continue;
          t.draw();
        }
      }

      // Flashes
      for (let i = whiteFlashes.length-1; i >= 0; i--) {
        const f = whiteFlashes[i];
        f.t += dt;
        const p = Math.min(1, f.t / f.life);
        const a = (p < 0.3) ? (p/0.3) : (1 - Math.max(0, (p-0.7)/0.3));
        const x = f.x * CELL_SIZE, y = f.y * CELL_SIZE + TOPBAR_HEIGHT;
        ctx.save(); ctx.globalAlpha = Math.max(0, a) * 0.9; ctx.strokeStyle = "#fff"; ctx.lineWidth = 3;
        ctx.strokeRect(x+2, y+2, CELL_SIZE-4, CELL_SIZE-4); ctx.restore();
        if (f.t >= f.life) whiteFlashes.splice(i,1);
      }

      // Striped preview
      if (stripedPreview) {
        const { type, idx, start, dur } = stripedPreview;
        const t = (now - start) / dur;
        if (t <= 1) {
          ctx.save(); ctx.globalAlpha = 0.8; ctx.fillStyle = '#ffffff';
          if (type === 'h') {
            const y = TOPBAR_HEIGHT + idx * CELL_SIZE + CELL_SIZE/2 - 1;
            const w = CANVAS_W * t; ctx.fillRect(0, y, w, 2);
          } else {
            const x = idx * CELL_SIZE + CELL_SIZE/2 - 1;
            const h = (CANVAS_H - TOPBAR_HEIGHT) * t; ctx.fillRect(x, TOPBAR_HEIGHT, 2, h);
          }
          ctx.restore();
        } else stripedPreview = null;
      }

      // Particles
      const budgetScale = Math.max(0.3, Math.min(1.0, 16.67 / avgDt));
      particleBudget = Math.floor(PARTICLE_BASE_BUDGET * budgetScale);
      updateParticles(dt);
      drawParticles(ctx);

      // Drag preview highlight
      if (dragStart && !swapState && !timeUp && hasStarted && !isPaused) {
        ctx.save(); ctx.globalAlpha = 0.35; ctx.fillStyle = "#fff";
        ctx.fillRect(dragStart.x * CELL_SIZE, dragStart.y * CELL_SIZE + TOPBAR_HEIGHT, CELL_SIZE, CELL_SIZE);
        if (dragPreviewTarget) { ctx.globalAlpha = 0.22; ctx.fillRect(dragPreviewTarget.x * CELL_SIZE, dragPreviewTarget.y * CELL_SIZE + TOPBAR_HEIGHT, CELL_SIZE, CELL_SIZE); }
        ctx.restore();
      }

      ctx.restore(); // end shaken playfield

      // Vignette pulse
      if (globalPulse > 0) {
        globalPulse = Math.max(0, globalPulse - dt/300);
        const g = ctx.createRadialGradient(CANVAS_W/2, CANVAS_H/2, 10, CANVAS_W/2, CANVAS_H/2, Math.max(CANVAS_W, CANVAS_H)/1.1);
        g.addColorStop(0, `rgba(0,0,0,${0.0 * globalPulse})`);
        g.addColorStop(1, `rgba(0,0,0,${0.25 * globalPulse})`);
        ctx.save(); ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.restore();
      }

      // Toasts
      drawToasts(dt);
      
      // Timer bonuses
      drawTimerBonuses(dt);

      // Debug overlay / Performance HUD
      if (debugMode) {
        ctx.save();
        ctx.fillStyle = "#fff"; ctx.font = "bold 14px Segoe UI, Arial";
        const fps = (1000 / avgDt).toFixed(0);
        const lines = [
          "DEBUG MODE",
          `FPS: ${fps}, avgDt: ${avgDt.toFixed(1)}ms`,
          `Particles: ${activeParticleCount}/${MAX_PARTICLES}`,
          `Specials queue: ${specialsToTrigger.length}`,
        ];
        lines.forEach((l, i) => ctx.fillText(l, CANVAS_W - 220, 18 + i * 16));
        ctx.restore();
        drawDebugSelector();
      }

      // Pause overlay (drawn in-canvas, buttons are HTML)
      if (isPaused && !timeUp) {
        ctx.save(); ctx.globalAlpha = 0.85; ctx.fillStyle = "#111";
        ctx.fillRect(0, TOPBAR_HEIGHT, canvas.width, canvas.height - TOPBAR_HEIGHT);
        ctx.globalAlpha = 1; ctx.fillStyle = "#fff"; ctx.textAlign = "center";
        ctx.font = "bold 56px Segoe UI, Arial, sans-serif"; ctx.fillText("Paused", CANVAS_W/2, CANVAS_H/2 - 20);
        ctx.font = "18px Segoe UI"; ctx.fillText("Press Esc to resume", CANVAS_W/2, CANVAS_H/2 + 18);
        ctx.restore();
      }

      // Countdown overlay
      if (!hasStarted && !timeUp && countdown > 0) {
        const elapsed = (performance.now() - countdownStart) / 1000;
        let stage = Math.floor(elapsed);
        let display = 3 - stage;
        if (display <= 0) display = "GO!";
        ctx.save(); ctx.globalAlpha = 0.85; ctx.fillStyle = "#111";
        ctx.fillRect(0, TOPBAR_HEIGHT, canvas.width, canvas.height - TOPBAR_HEIGHT);
        ctx.globalAlpha = 1; ctx.fillStyle = "#fff"; ctx.textAlign = "center";
        ctx.font = "bold 80px Segoe UI, Arial"; ctx.fillText(display, CANVAS_W/2, CANVAS_H/2 + 20);
        ctx.restore();
      }

      // Time up overlay
      if (timeUp) {
        ctx.save(); ctx.globalAlpha = 0.8; ctx.fillStyle = "#111";
        ctx.fillRect(0, TOPBAR_HEIGHT, canvas.width, canvas.height - TOPBAR_HEIGHT);
        ctx.globalAlpha = 1; ctx.fillStyle = "#fff"; ctx.textAlign = "center";
        ctx.font = "bold 56px Segoe UI, Arial, sans-serif"; ctx.fillText("Time's Up!", CANVAS_W / 2, CANVAS_H / 2 - 40);
        ctx.font = "bold 32px Segoe UI, Arial, sans-serif"; ctx.fillText(`Score: ${score}`, CANVAS_W / 2, CANVAS_H / 2 + 10);
        ctx.font = "22px Segoe UI"; ctx.fillText(`Best: ${bestScore}`, CANVAS_W / 2, CANVAS_H / 2 + 42);
        ctx.font = "18px Segoe UI"; ctx.fillText("Press Restart or [R]", CANVAS_W / 2, CANVAS_H / 2 + 78);
        ctx.restore();
        resetBtn.textContent = "Restart";
      }
    }

    // Debug selector UI
    function drawDebugSelector() {
      if (!debugSelector) return;
      ctx.save(); ctx.globalAlpha = 0.97; ctx.fillStyle = "#181a2a"; ctx.fillRect(0, 0, CANVAS_W, 32 + 32);
      COLORS.forEach((c, i) => { ctx.fillStyle = c; ctx.fillRect(8 + i * 42, 4, 36, 24); ctx.strokeStyle = '#fff'; ctx.strokeRect(8 + i * 42, 4, 36, 24); });
      const specials = ['none', 'horizontal', 'vertical', 'bomb', 'color'];
      specials.forEach((s, i) => {
        ctx.fillStyle = "#555"; ctx.fillRect(8 + i * 60, 36, 54, 24); ctx.strokeStyle = '#fff'; ctx.strokeRect(8 + i * 60, 36, 54, 24);
        ctx.fillStyle = "#fff"; ctx.font = "14px sans-serif"; ctx.fillText(s, 14 + i * 60, 53);
      });
      ctx.restore();
    }

    // --- Match Logic helpers ---
    function getCell(e) {
      const r = canvas.getBoundingClientRect();
      const localX = (e.clientX - r.left) - currentShakeX;
      const localY = (e.clientY - r.top) - currentShakeY - TOPBAR_HEIGHT;
      const x = Math.floor(localX / CELL_SIZE);
      const y = Math.floor(localY / CELL_SIZE);
      return { x, y };
    }
    function getCellFromClient(clientX, clientY) {
      const r = canvas.getBoundingClientRect();
      const localX = (clientX - r.left) - currentShakeX;
      const localY = (clientY - r.top) - currentShakeY - TOPBAR_HEIGHT;
      const x = Math.floor(localX / CELL_SIZE);
      const y = Math.floor(localY / CELL_SIZE);
      return { x, y };
    }
    function isAdj(a, b) { return Math.abs(a.x - b.x) + Math.abs(a.y - b.y) === 1; }

    function hasAnyLegalMove() {
      // try swapping each tile with right/down neighbor and check for a 3+ run
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const here = grid[y][x];
          if (!isMatchableTile(here)) continue;

          // swap right
          if (x+1 < GRID_SIZE) {
            swapColors({x,y},{x:x+1,y});
            if (findAllRuns().length) { swapColors({x,y},{x:x+1,y}); return true; }
            swapColors({x,y},{x:x+1,y});
          }
          // swap down
          if (y+1 < GRID_SIZE) {
            swapColors({x,y},{x,y:y+1});
            if (findAllRuns().length) { swapColors({x,y},{x,y:y+1}); return true; }
            swapColors({x,y},{x,y:y+1});
          }
        }
      }
      return false;
    }

    function swapColors(a, b) {
      const ta = grid[a.y][a.x], tb = grid[b.y][b.x];
      
      // Swap positions in the grid
      grid[a.y][a.x] = tb;
      grid[b.y][b.x] = ta;
      
      // Update tile coordinates
      const tempX = ta.x, tempY = ta.y;
      ta.x = tb.x; ta.y = tb.y;
      tb.x = tempX; tb.y = tempY;
      
      // Update target positions
      ta.targetPy = ta.y * CELL_SIZE + TOPBAR_HEIGHT;
      tb.targetPy = tb.y * CELL_SIZE + TOPBAR_HEIGHT;
    }

    // simple reshuffle that preserves colors present; repeats until a legal move exists
    function reshuffleBoard() {
      const tiles = [];
      for (let y = 0; y < GRID_SIZE; y++) for (let x = 0; x < GRID_SIZE; x++) {
        const t = grid[y][x];
        if (t) tiles.push(t.color);
      }
      // Fisher–Yates
      for (let i = tiles.length - 1; i > 0; i--) {
        const j = (Math.random() * (i + 1)) | 0;
        const tmp = tiles[i]; tiles[i] = tiles[j]; tiles[j] = tmp;
      }
      let k = 0;
      for (let y = 0; y < GRID_SIZE; y++) for (let x = 0; x < GRID_SIZE; x++) {
        const t = grid[y][x];
        if (t) { t.color = tiles[k++]; t.special = null; t.matching = false; }
      }
      // avoid starting matches
      clearInitialMatches();
    }

    function getGroups() {
      return findAllRuns();
    }

    // toast + preview when a special is created
    function onSpecialCreated(tile) {
      const cx = tile.x * CELL_SIZE + CELL_SIZE/2;
      const cy = TOPBAR_HEIGHT + tile.y * CELL_SIZE + CELL_SIZE/2;
      if (tile.special === 'horizontal') { addToast('Striped!', cx, cy - 28); stripedPreview = { type:'h', idx: tile.y, start: performance.now(), dur: 200 }; }
      else if (tile.special === 'vertical') { addToast('Striped!', cx, cy - 28); stripedPreview = { type:'v', idx: tile.x, start: performance.now(), dur: 200 }; }
      else if (tile.special === 'bomb') { addToast('Bomb!', cx, cy - 28); }
      else if (tile.special === 'color') { addToast('Color Bomb!', cx, cy - 28); }
      whiteFlashes.push({ x: tile.x, y: tile.y, t: 0, life: 160 });
    }

    function findAllRuns() {
      const runs = [];

      // Horizontal detection - FIXED VERSION
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE - 2; x++) {
          const tile = grid[y][x];
          if (!tile || !isMatchableTile(tile)) continue;
          
          const color = tile.color;
          let runLength = 1;
          
          // Check how many consecutive same color tiles to the right
          while (x + runLength < GRID_SIZE) {
            const nextTile = grid[y][x + runLength];
            if (!nextTile || !sameBaseColor(nextTile, color)) break;
            runLength++;
          }
          
          // If we found a run of 3 or more
          if (runLength >= 3) {
            const positions = [];
            for (let i = 0; i < runLength; i++) {
              positions.push({ x: x + i, y });
            }
            runs.push({ positions, orient: 'h' });
          }
        }
      }

      // Vertical detection - FIXED VERSION
      for (let x = 0; x < GRID_SIZE; x++) {
        for (let y = 0; y < GRID_SIZE - 2; y++) {
          const tile = grid[y][x];
          if (!tile || !isMatchableTile(tile)) continue;
          
          const color = tile.color;
          let runLength = 1;
          
          // Check how many consecutive same color tiles downward
          while (y + runLength < GRID_SIZE) {
            const nextTile = grid[y + runLength][x];
            if (!nextTile || !sameBaseColor(nextTile, color)) break;
            runLength++;
          }
          
          // If we found a run of 3 or more
          if (runLength >= 3) {
            const positions = [];
            for (let i = 0; i < runLength; i++) {
              positions.push({ x, y: y + i });
            }
            runs.push({ positions, orient: 'v' });
          }
        }
      }

      return runs;
    }

    // === Priority: (1) straight 5+ ⇒ COLOR BOMB  (2) 5 in L/T ⇒ BOMB
    //                (3) straight 4 ⇒ STRIPED
    //                 (4) clear all 3+ ===
function markMatchesV3(runs, movedTiles = []) {
  const used = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(false));
  console.log("Runs detected:", runs.map(r => ({len: r.positions.length, orient: r.orient, pos: r.positions})));
  let specials = [];

  // --- priority 1: any straight 5+ must become a Color Bomb ---
  let bestLine = null; // {orient, pivot:{x,y}, len}
  const straight = runs.filter(g => g.orient === 'h' || g.orient === 'v');

  for (const r of straight) {
    for (const p of r.positions) {
      const ll = measureLineLength(p.x, p.y, r.orient);
      if (!bestLine || ll > bestLine.len) {
        bestLine = { orient: r.orient, pivot: { x: p.x, y: p.y }, len: ll };
      }
    }
  }

  if (bestLine && bestLine.len >= 5) {
    // choose a good pivot: moved tile if present & not already special; else any non-special in that line; else center-ish
    const isMoved = (q) => movedTiles && movedTiles.some(m => m.x === q.x && m.y === q.y);
    // collect the whole line positions to mark clears (using the same scan logic)
    const { orient, pivot } = bestLine;
    const color = grid[pivot.y][pivot.x].color;
    const linePositions = [];

    // walk negative
    let i = 0;
    while (true) {
      const nx = orient === 'h' ? pivot.x - i : pivot.x;
      const ny = orient === 'h' ? pivot.y : pivot.y - i;
      const t = grid[ny]?.[nx];
      if (!sameBaseColor(t, color)) break;
      linePositions.push({ x: nx, y: ny });
      i++;
    }
    // walk positive (skip pivot because already included at i=0)
    i = 1;
    while (true) {
      const nx = orient === 'h' ? pivot.x + i : pivot.x;
      const ny = orient === 'h' ? pivot.y : pivot.y + i;
      const t = grid[ny]?.[nx];
      if (!sameBaseColor(t, color)) break;
      linePositions.push({ x: nx, y: ny });
      i++;
    }

    // pick final color-bomb tile
    let cbPos =
      linePositions.find(pos => isMoved(pos) && !grid[pos.y][pos.x].special) ||
      linePositions.find(pos => !grid[pos.y][pos.x].special) ||
      linePositions[Math.floor(linePositions.length / 2)];

    const cbTile = grid[cbPos.y][cbPos.x];
    cbTile.special = 'color';
    onSpecialCreated(cbTile);

    // mark the rest for clear
    for (const pos of linePositions) {
      if (pos.x === cbPos.x && pos.y === cbPos.y) continue;
      const t = grid[pos.y][pos.x];
      t.matching = true;
      // If any specials are inside the line, queue them so they actually fire
      if (t.special && t.special !== 'color' && !t.triggered && !specialsToTrigger.includes(t)) {
        specialsToTrigger.push(t);
      }
    }
    return; // IMPORTANT: stop here so 5/4 rules don't override
  }

// 2. T/L shapes (bomb)
for (const h of runs.filter(r => r.orient === 'h' && r.positions.length >= 3)) {
  for (const v of runs.filter(r => r.orient === 'v' && r.positions.length >= 3)) {
    const overlap = h.positions.find(p => v.positions.some(q => q.x === p.x && q.y === p.y));
    if (!overlap) continue;
    const uniq = new Map();
    [...h.positions, ...v.positions].forEach(pos => {
      if (!used[pos.y][pos.x]) uniq.set(`${pos.x},${pos.y}`, pos);
    });
    if (uniq.size >= 5) {
      specials.push({type: 'bomb', run: [...uniq.values()], pivot: overlap});
      [...uniq.values()].forEach(pos => used[pos.y][pos.x] = true); // Changed p to pos
    }
  }
}

  // 3. Straight 4 (striped)
  for (const run of runs) {
    if (run.positions.length === 4 && !run.positions.some(pos => used[pos.y][pos.x])) {
      specials.push({type: run.orient === 'h' ? 'horizontal' : 'vertical', run: run.positions, orient: run.orient});
      run.positions.forEach(pos => used[pos.y][pos.x] = true);
    }
  }

  // Place specials and mark for removal
  for (const s of specials) {
    let pivot = s.pivot ||
      s.run.find(pos => movedTiles.some(m => m.x === pos.x && m.y === pos.y) && !grid[pos.y][pos.x].special) ||
      s.run.find(pos => !grid[pos.y][pos.x].special) ||
      s.run[Math.floor(s.run.length/2)];
    const t = grid[pivot.y][pivot.x];
    if (!t.special) {
      t.special = s.type;
      t.matching = false;
      onSpecialCreated(t);
      used[pivot.y][pivot.x] = true;
    }
    s.run.forEach(pos => {
      if (pos.x !== pivot.x || pos.y !== pivot.y) {
        grid[pos.y][pos.x].matching = true;
        whiteFlashes.push({x:pos.x,y:pos.y,t:0,life:120});
        // Trigger special if present
        const tile = grid[pos.y][pos.x];
        if (tile.special && !tile.triggered && !specialsToTrigger.includes(tile)) {
          specialsToTrigger.push(tile);
        }
      }
    });
  }

  // Default: mark all remaining run tiles for removal and award points
  for (const g of runs) {
    for (const pos of g.positions) {
      if (used[pos.y][pos.x]) continue;
      const t = grid[pos.y][pos.x];
      if (!t) continue;
      t.matching = true;
      let basePoints = 0;
      if (!t.special) {
        if (g.positions.length === 3) basePoints = 60;
        else if (g.positions.length === 4) basePoints = 120;
        else if (g.positions.length >= 5) basePoints = 200;
        
        // Add time bonus based on match size
        if (g.positions.length === 3) addTime(TIMER_BONUS_SMALL, pos.x, pos.y);
        else if (g.positions.length === 4) addTime(TIMER_BONUS_MEDIUM, pos.x, pos.y);
        else if (g.positions.length >= 5) addTime(TIMER_BONUS_LARGE, pos.x, pos.y);
      }
      // If run contains a special (not color bomb), queue it to trigger
      if (t.special && t.special !== 'color' && !t.triggered && !specialsToTrigger.includes(t)) {
        specialsToTrigger.push(t);
      }
    }
  }
}

    function getMatchGrid() {
      // Returns a 2D array of booleans: true if matched
      const matched = Array.from({length: GRID_SIZE}, () => Array(GRID_SIZE).fill(false));
      // Horizontal
      for (let y = 0; y < GRID_SIZE; y++) {
        let run = 1;
        for (let x = 1; x < GRID_SIZE; x++) {
          if (sameBaseColor(grid[y][x], grid[y][x-1].color)) {
            run++;
          } else {
            if (run >= 3) for (let k = 0; k < run; k++) matched[y][x-1-k] = true;
            run = 1;
          }
        }
        if (run >= 3) for (let k = 0; k < run; k++) matched[y][GRID_SIZE-1-k] = true;
      }
      // Vertical
      for (let x = 0; x < GRID_SIZE; x++) {
        let run = 1;
        for (let y = 1; y < GRID_SIZE; y++) {
          if (sameBaseColor(grid[y][x], grid[y-1][x].color)) {
            run++;
          } else {
            if (run >= 3) for (let k = 0; k < run; k++) matched[y-1-k][x] = true;
            run = 1;
          }
        }
        if (run >= 3) for (let k = 0; k < run; k++) matched[GRID_SIZE-1-k][x] = true;
      }
      return matched;
    }

    function highlightSpecialArea(tile) {
      for (let y = 0; y < GRID_SIZE; y++) {
        const row = grid[y];
        for (let x = 0; x < GRID_SIZE; x++) {
          const t = row[x];
          if (t) t.highlight = false;
        }
      }
      const type = tile.special;
      if (type === 'horizontal') { for (let x = 0; x < GRID_SIZE; x++) grid[tile.y][x].highlight = true; }
      else if (type === 'vertical') { for (let y = 0; y < GRID_SIZE; y++) grid[y][tile.x].highlight = true; }
      else if (type === 'bomb') { for (let dy = -1; dy <= 1; dy++) for (let dx = -1; dx <= 1; dx++) { const X = tile.x + dx, Y = tile.y + dy; if (grid[Y]?.[X]) grid[Y][X].highlight = true; } }
      else if (type === 'color') { const c = tile.color; for (let y = 0; y < GRID_SIZE; y++) for (let x = 0; x < GRID_SIZE; x++) if (grid[y][x].color === c) grid[y][x].highlight = true; }
      draw();
    }

    function triggerSpecial(tile) {
      if (tile.triggered || highlightingSpecial) return;
      tile.triggered = true; highlightingSpecial = true; combo++; comboPulse = 1; SFX.special();

      if (tile.special === 'bomb') addShake(6);
      else if (tile.special === 'horizontal' || tile.special === 'vertical') addShake(3);
      else if (tile.special === 'color') addShake(2);

      highlightSpecialArea(tile);
      setTimeout(() => {
        for (let y = 0; y < GRID_SIZE; y++) {
          const row = grid[y];
          for (let x = 0; x < GRID_SIZE; x++) {
            const t = row[x];
            if (t) t.highlight = false;
          }
        }
        highlightingSpecial = false;
        tile.matching = true;
        tile.animProgress = 0;

        const type = tile.special;
        if (type === 'horizontal') {
          for (let x = 0; x < GRID_SIZE; x++) {
            const t = grid[tile.y][x];
            if (t && !t.matching && t !== tile) {
              if (t.special && !t.triggered && !specialsToTrigger.includes(t)) specialsToTrigger.push(t);
              t.matching = true; t.animProgress = 0; score += combo;
              if (t.special && t.special !== 'color' && !t.triggered && !specialsToTrigger.includes(t)) {
                specialsToTrigger.push(t);
              }
              whiteFlashes.push({ x: t.x, y: t.y, t: 0, life: 120 });
              addScore(SCORE_BONUS_STRIPED);
              addTime(TIMER_BONUS_SPECIAL, t.x, t.y); // Add time bonus
            }
          }
        } else if (type === 'vertical') {
          for (let y = 0; y < GRID_SIZE; y++) {
            const t = grid[y][tile.x];
            if (t && !t.matching && t !== tile) {
              if (t.special && !t.triggered && !specialsToTrigger.includes(t)) specialsToTrigger.push(t);
              t.matching = true; t.animProgress = 0; score += combo;
              if (t.special && t.special !== 'color' && !t.triggered && !specialsToTrigger.includes(t)) {
                specialsToTrigger.push(t);
              }
              whiteFlashes.push({ x: t.x, y: t.y, t: 0, life: 120 });
              addScore(SCORE_BONUS_STRIPED);
              addTime(TIMER_BONUS_SPECIAL, t.x, t.y); // Add time bonus
            }
          }
        } else if (type === 'bomb') {
          for (let dy = -1; dy <= 1; dy++) for (let dx = -1; dx <= 1; dx++) {
            const X = tile.x + dx, Y = tile.y + dy;
            const t = grid[Y]?.[X];
            if (t && !t.matching && t !== tile) {
              if (t.special && !t.triggered && !specialsToTrigger.includes(t)) specialsToTrigger.push(t);
              t.matching = true; t.animProgress = 0; score += combo;
              if (t.special && t.special !== 'color' && !t.triggered && !specialsToTrigger.includes(t)) {
                specialsToTrigger.push(t);
              }
              whiteFlashes.push({ x: t.x, y: t.y, t: 0, life: 120 });
              addScore(SCORE_BONUS_BOMB);
              addTime(TIMER_BONUS_SPECIAL, t.x, t.y); // Add time bonus
            }
          }
        } else if (type === 'color') {
          const c = tile.color;
          for (let y = 0; y < GRID_SIZE; y++) for (let x = 0; x < GRID_SIZE; x++) {
            const t = grid[y][x];
            if (t.color === c && !t.matching && t !== tile) {
              if (t.special && !t.triggered && !specialsToTrigger.includes(t)) specialsToTrigger.push(t);
              t.matching = true; t.animProgress = 0; score += combo;
              if (t.special && t.special !== 'color' && !t.triggered && !specialsToTrigger.includes(t)) {
                specialsToTrigger.push(t);
              }
              whiteFlashes.push({ x: t.x, y: t.y, t: 0, life: 120 });
              addScore(SCORE_BONUS_COLOR);
              addTime(TIMER_BONUS_SPECIAL, t.x, t.y); // Add time bonus
            }
          }
        }
      }, 50);
    }

    function resetPos() {
      for (let y = 0; y < GRID_SIZE; y++) {
        const row = grid[y];
        for (let x = 0; x < GRID_SIZE; x++) {
          const t = row[x];
          if (!t) continue;
          t.px = t.x * CELL_SIZE;
          t.py = t.y * CELL_SIZE + TOPBAR_HEIGHT;
          t.nudgeX = 0; t.nudgeY = 0; t.nudgeT = 0;
          t.rotation = 0; t.scale = 1; t.alpha = 1;
          t.spawnScale = Math.max(1, t.spawnScale);
        }
      }
    }

    function startSwap(a, b) {
      if (!hasStarted || isPaused) return;
      const aTile = grid[a.y][a.x];
      const bTile = grid[b.y][b.x];
      
      // Handle color bomb + regular tile case
      if ((aTile.special === 'color' && !bTile.special) || 
          (bTile.special === 'color' && !aTile.special)) {
        // Determine which is the color bomb and which is the normal tile
        const colorBombTile = aTile.special === 'color' ? aTile : bTile;
        const colorTile = aTile.special === 'color' ? bTile : aTile;
        
        // Trigger color bomb effect for this color
        triggerColorBombByColor(colorBombTile, colorTile.color);
        resetPos(); 
        swapState = null;
        return;
      }
      
      // Regular swap (including special + regular tile)
      swapState = { aTile, bTile, a, b, progress: 0, rev: false, dir: (b.x !== a.x ? 'horizontal' : 'vertical') };
      SFX.swap();
      animating = true;
      requestAnimationFrame(swapStep);
    }

    function swapStep() {
      const s = swapState;
      s.progress = Math.min(s.progress + SWAP_SPEED, 1);
      const ax = s.a.x * CELL_SIZE, ay = s.a.y * CELL_SIZE + TOPBAR_HEIGHT;
      const bx = s.b.x * CELL_SIZE, by = s.b.y * CELL_SIZE + TOPBAR_HEIGHT;
      s.aTile.px = ax + (bx - ax) * s.progress;
      s.aTile.py = ay + (by - ay) * s.progress;
      s.bTile.px = bx + (ax - bx) * s.progress;
      s.bTile.py = by + (ay - by) * s.progress;
      draw();
      if (s.progress < 1) return requestAnimationFrame(swapStep);

      const aTile = s.aTile, bTile = s.bTile;

      // Color-bomb combos
      if (aTile.special === 'color' && bTile.special === 'color') {
        triggerDoubleColorBomb(aTile, bTile);
        resetPos(); swapState = null; return;
      }
      if (aTile.special === 'color' && bTile.special && bTile.special !== 'color') {
        triggerColorBombCombo(aTile, bTile);
        resetPos(); swapState = null; requestAnimationFrame(matchStep); return;
      }
      if (bTile.special === 'color' && aTile.special && aTile.special !== 'color') {
        triggerColorBombCombo(bTile, aTile);
        resetPos(); swapState = null; requestAnimationFrame(matchStep); return;
      }

      // Line/bomb special combos
      const comboType = getSpecialComboType(aTile, bTile);
      if (comboType === 'plus') {
        const cx = s.b.x, cy = s.b.y;
        triggerPlusCombo(cx, cy, s.a, s.b);
        resetPos(); swapState = null; requestAnimationFrame(matchStep); return;
      }
      if (comboType === 'double_horizontal') {
        const cx = s.b.x, cy = s.b.y;
        triggerDoubleHorizontalCombo(cx, cy, s.a, s.b);
        resetPos(); swapState = null; requestAnimationFrame(matchStep); return;
      }
      if (comboType === 'double_vertical') {
        const cx = s.b.x, cy = s.b.y;
        triggerDoubleVerticalCombo(cx, cy, s.a, s.b);
        resetPos(); swapState = null; requestAnimationFrame(matchStep); return;
      }

      // Standard swap - PROPERLY swap the tiles in the grid
      // Swap the actual tile objects in the grid array
      grid[s.a.y][s.a.x] = bTile;
      grid[s.b.y][s.b.x] = aTile;
      
      // Update tile coordinates
      const tempX = aTile.x, tempY = aTile.y;
      aTile.x = bTile.x; aTile.y = bTile.y;
      bTile.x = tempX; bTile.y = tempY;
      
      // Update target positions
      aTile.targetPy = aTile.y * CELL_SIZE + TOPBAR_HEIGHT;
      bTile.targetPy = bTile.y * CELL_SIZE + TOPBAR_HEIGHT;

      const runs = findAllRuns();
      if (runs.length) {
        combo++; comboPulse = 1;
        markMatchesV3(runs, [{ x: s.a.x, y: s.a.y }, { x: s.b.x, y: s.b.y }]);
        resetPos(); swapState = null;
        requestAnimationFrame(matchStep);
      } else {
        // No match: reverse the swap with animation
        requestAnimationFrame(reverseSwap);
      }
    }

    function reverseSwap() {
      const s = swapState;
      if (!s.rev) {
        s.rev = true;
        // Reverse the tile positions in the grid
        grid[s.a.y][s.a.x] = s.aTile;
        grid[s.b.y][s.b.x] = s.bTile;
        
        // Reverse tile coordinates
        const tempX = s.aTile.x, tempY = s.aTile.y;
        s.aTile.x = s.bTile.x; s.aTile.y = s.bTile.y;
        s.bTile.x = tempX; s.bTile.y = tempY;
        
        // Update target positions
        s.aTile.targetPy = s.aTile.y * CELL_SIZE + TOPBAR_HEIGHT;
        s.bTile.targetPy = s.bTile.y * CELL_SIZE + TOPBAR_HEIGHT;
        
        s.aTile.nudgeX = s.aTile.nudgeY = 0; s.aTile.nudgeT = 0;
        s.bTile.nudgeX = s.bTile.nudgeY = 0; s.bTile.nudgeT = 0;
      }
      s.progress = Math.max(s.progress - SWAP_SPEED, 0);
      const ax = s.a.x * CELL_SIZE, ay = s.a.y * CELL_SIZE + TOPBAR_HEIGHT;
      const bx = s.b.x * CELL_SIZE, by = s.b.y * CELL_SIZE + TOPBAR_HEIGHT;
      s.aTile.px = ax + (bx - ax) * s.progress;
      s.aTile.py = ay + (by - ay) * s.progress;
      s.bTile.px = bx + (ax - bx) * s.progress;
      s.bTile.py = by + (ay - by) * s.progress;
      draw();
      if (s.progress > 0) return requestAnimationFrame(reverseSwap);
      resetPos(); swapState = null; animating = false; SFX.invalid();
    }

    let lastAnimTick = performance.now();
    function matchStep() {
      if (highlightingSpecial) { draw(); requestAnimationFrame(matchStep); return; }
      const now = performance.now();
      const dt = now - lastAnimTick; lastAnimTick = now;

      let any = false;
      grid.flat().forEach(t => {
        const r = t.update(dt);
        if (r === 'remove') {
          const cx = t.px + CELL_SIZE * 0.5;
          const cy = t.py + CELL_SIZE * 0.5;
          spawnParticles(cx, cy, t.color, t.special ? 12 : 6);
          SFX.pop();
          if (t.special && !t.triggered && !specialsToTrigger.includes(t)) specialsToTrigger.push(t);
          addScore(SCORE_TILE);
          t.toRemove = true;
        }
        if (t.matching) any = true;
      });
      draw();

      if (any) {
        requestAnimationFrame(matchStep);
      } else if (specialsToTrigger.length > 0) {
        const queue = specialsToTrigger.slice();
        specialsToTrigger.length = 0;
        queue.forEach(t => {
          if (grid[t.y] && grid[t.y][t.x] === t && t.special) triggerSpecial(t);
        });
        requestAnimationFrame(matchStep);
      } else {
        cleanup();
      }
    }

    function cleanup() {
      for (let y = 0; y < GRID_SIZE; y++)
        for (let x = 0; x < GRID_SIZE; x++)
          if (grid[y][x]?.toRemove) grid[y][x] = null;
      collapse();
    }

    function collapse() {
      for (let x = 0; x < GRID_SIZE; x++) {
        const col = [];
        for (let y = GRID_SIZE - 1; y >= 0; y--) if (grid[y][x]) col.push(grid[y][x]);
        const miss = GRID_SIZE - col.length;
        for (let i = 0; i < miss; i++) col.push(new Tile(randomColor(), x, -1));
        for (let y = GRID_SIZE - 1; y >= 0; y--) {
          const t = col[GRID_SIZE - 1 - y];
          t.x = x; t.y = y; t.targetPy = y * CELL_SIZE + TOPBAR_HEIGHT;
          t.matching = false; t.toRemove = false; t.animProgress = 0;
          t.scale = 1; t.alpha = 1; t.triggered = false; t.highlight = false;
          if (t.py < t.targetPy && t.spawnScale === 1) t.spawnScale = 0.85;
          grid[y][x] = t;
        }
      }
      requestAnimationFrame(fall);
    }

    function fall() {
      let moving = false;
      grid.flat().forEach(t => { if (t.update(16.67) || t.py < t.targetPy) moving = true; });
      draw();
      if (moving) {
        requestAnimationFrame(fall);
      } else {
        const runs = findAllRuns();
        if (runs.length) {
          combo++; comboPulse = 1;
          markMatchesV3(runs, []);
          requestAnimationFrame(matchStep);
        } else {
          animating = false; combo = 0;
          if (!hasAnyLegalMove()) {
            reshuffleBoard();
            draw();
          }
        }
      }
    }

    // --- Input polish (pointer events + preview) ---
    let pointerDown = false;
    let dragThreshold = 8;
    let dragCurrent = null;
    let dragPreviewTarget = null;
    let pointerStartClientX = 0, pointerStartClientY = 0;

    canvas.addEventListener('pointerdown', e => {
      if (debugMode && debugSelector) return;
      if (animating || timeUp || isPaused || !hasStarted) return;
      
      canvas.setPointerCapture(e.pointerId);
      pointerDown = true;
      
      dragStartTime = Date.now();
      dragStartPosition = { x: e.clientX, y: e.clientY };
      isDrag = false;
      
      pointerStartClientX = e.clientX; 
      pointerStartClientY = e.clientY;
      const c = getCellFromClient(e.clientX, e.clientY);
      
      if (c.y < 0 || c.y >= GRID_SIZE || c.x < 0 || c.x >= GRID_SIZE) return;
      dragStart = c; 
      dragCurrent = c; 
      dragPreviewTarget = null;
    });

    canvas.addEventListener('pointermove', e => {
      if (!pointerDown || !dragStart || animating || swapState || timeUp || isPaused || !hasStarted) return;
      
      const c = getCellFromClient(e.clientX, e.clientY); 
      dragCurrent = c;
      
      const dx = e.clientX - pointerStartClientX;
      const dy = e.clientY - pointerStartClientY;
      const adx = Math.abs(dx), ady = Math.abs(dy);
      
      // NEW: Set drag flag if movement exceeds threshold
      if (adx > dragThreshold || ady > dragThreshold) {
        isDrag = true;
        
        let target = { x: dragStart.x, y: dragStart.y };
        if (adx > ady) target.x += (dx > 0 ? 1 : -1);
        else target.y += (dy > 0 ? 1 : -1);
        
        if (target.x >= 0 && target.x < GRID_SIZE && target.y >= 0 && target.y < GRID_SIZE) {
          dragPreviewTarget = target;
          if (isAdj(dragStart, target)) {
            startSwap(dragStart, target);
            dragStart = null;
            dragPreviewTarget = null;
            pointerDown = false;
          }
        }
      }
    });

    canvas.addEventListener('pointerup', e => {
      pointerDown = false; 
      dragStart = null; 
      dragPreviewTarget = null; 
      dragCurrent = null;
      isDrag = false; 
      try { canvas.releasePointerCapture(e.pointerId); } catch {}
    });

    canvas.addEventListener('pointerleave', () => {
      pointerDown = false; 
      dragStart = null; 
      dragPreviewTarget = null; 
      dragCurrent = null;
      isDrag = false; 
    });

    // Click to activate special
    canvas.addEventListener('click', e => {
      if (animating || timeUp || isPaused || !hasStarted || isDrag) return;
      
      // Check if this was a quick click (not a failed drag attempt)
      const clickDuration = Date.now() - dragStartTime;
      const dragDistance = dragStartPosition ? 
        Math.hypot(e.clientX - dragStartPosition.x, e.clientY - dragStartPosition.y) : 0;
      
      // Only activate special for quick, short-distance clicks
      if (clickDuration < 250 && dragDistance < 15) {
        const c = getCell(e);
        const t = grid[c.y]?.[c.x];
        
        if (t && t.special) {
          animating = true; 
          combo = 1;
          triggerSpecial(t);
          requestAnimationFrame(matchStep);
        }
      }
    });

    // Debug context menu (open palette)
    canvas.addEventListener('contextmenu', e => {
      if (!debugMode) return;
      e.preventDefault();
      const cell = getCell(e);
      if (cell.x < 0 || cell.x >= GRID_SIZE || cell.y < 0 || cell.y >= GRID_SIZE) return;
      debugSelector = { x: cell.x, y: cell.y };
      draw();
    });

    canvas.addEventListener('mousedown', e => {
      if (!debugMode || !debugSelector) return;
      const mx = e.offsetX, my = e.offsetY;
      for (let i = 0; i < COLORS.length; i++) {
        if (mx >= 8 + i * 42 && mx <= 44 + i * 42 && my >= 4 && my <= 28) {
          grid[debugSelector.y][debugSelector.x].color = COLORS[i];
          grid[debugSelector.y][debugSelector.x].special = null;
          debugSelector = null; draw(); return;
        }
      }
      const specials = ['none', 'horizontal', 'vertical', 'bomb', 'color'];
      for (let i = 0; i < specials.length; i++) {
        if (mx >= 8 + i * 60 && mx <= 62 + i * 60 && my >= 36 && my <= 60) {
          if (specials[i] === 'none') grid[debugSelector.y][debugSelector.x].special = null;
          else grid[debugSelector.y][debugSelector.x].special = specials[i];
          debugSelector = null; draw(); return;
        }
      }
      debugSelector = null; draw();
    }, true);

    // Options & pause controls
    function applyOptionsUI() {
      optSfx.checked = !!OPTIONS.sfx;
      optShake.checked = !!OPTIONS.shake;
      optParticles.value = OPTIONS.particles || 'med';
      optReduce.checked = !!OPTIONS.reduceMotion;
      optVolume.value = Math.round((OPTIONS.volume ?? 0.9) * 100);
    }
    function attachOptionHandlers() {
      optSfx.addEventListener('change', () => { OPTIONS.sfx = optSfx.checked; saveOptions(); });
      optShake.addEventListener('change', () => { OPTIONS.shake = optShake.checked; saveOptions(); });
      optParticles.addEventListener('change', () => { OPTIONS.particles = optParticles.value; saveOptions(); });
      optReduce.addEventListener('change', () => { OPTIONS.reduceMotion = optReduce.checked; saveOptions(); });
      optVolume.addEventListener('input', () => {
        OPTIONS.volume = (parseInt(optVolume.value, 10) || 0) / 100;
        saveOptions(); rampToVolume(OPTIONS.volume, 0.1);
      });
    }

    function togglePause(force) {
      const next = (typeof force === 'boolean') ? force : !isPaused;
      if (timeUp || !hasStarted) return;
      isPaused = next;
      overlayButtons.style.display = isPaused ? 'flex' : 'none';
      draw();
    }

    pauseBtn.addEventListener('click', () => togglePause());
    resumeBtn.addEventListener('click', () => togglePause(false));
    overlayRestartBtn.addEventListener('click', () => startGame());

    optionsBtn.addEventListener('click', () => {
      optionsPanel.style.display = optionsPanel.style.display === 'none' ? 'block' : 'none';
    });

    window.addEventListener('keydown', e => {
      if (e.key === 'Escape') togglePause();
      if (e.key === 'd' || e.key === 'D') { debugMode = !debugMode; debugSelector = null; draw(); }
      if ((e.key === 'r' || e.key === 'R') && timeUp) startGame();
    });

    resetBtn.onclick = startGame;

    // boot
    applyOptionsUI();
    attachOptionHandlers();
    startGame();
  </script>
</body>
</html>